# kit-ui 性能优化开发文档

## 概述

kit-ui 组件库致力于在各个平台上提供高性能的用户体验。本文档详细说明了组件库的性能优化策略、监控方案和最佳实践，涵盖渲染性能、内存管理、网络优化、包体积优化等多个方面。

---

## 1. 渲染性能优化

### 1.1 虚拟滚动实现

```vue
<!-- k-virtual-list.vue -->
<template>
  <view class="k-virtual-list" :style="containerStyle">
    <view 
      class="k-virtual-list__phantom" 
      :style="{ height: totalHeight + 'px' }"
    ></view>
    
    <view 
      class="k-virtual-list__content"
      :style="contentStyle"
      @scroll="handleScroll"
    >
      <view 
        v-for="item in visibleItems" 
        :key="getItemKey(item)"
        class="k-virtual-list__item"
        :style="getItemStyle(item)"
      >
        <slot :item="item.data" :index="item.index"></slot>
      </view>
    </view>
  </view>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted, nextTick } from 'vue';
import { throttle } from '../utils/performance';

interface VirtualListItem {
  data: any;
  index: number;
  height: number;
  top: number;
}

interface Props {
  items: any[];
  itemHeight: number | ((item: any, index: number) => number);
  height: number;
  overscan?: number;
  keyField?: string;
}

const props = withDefaults(defineProps<Props>(), {
  overscan: 5,
  keyField: 'id'
});

const scrollTop = ref(0);
const containerRef = ref<HTMLElement>();
const itemHeights = ref<number[]>([]);
const itemPositions = ref<{ top: number; height: number }[]>([]);

// 计算总高度
const totalHeight = computed(() => {
  if (itemPositions.value.length === 0) {
    return props.items.length * (typeof props.itemHeight === 'number' ? props.itemHeight : 50);
  }
  
  const lastItem = itemPositions.value[itemPositions.value.length - 1];
  return lastItem.top + lastItem.height;
});

// 计算可见区域的项目
const visibleItems = computed(() => {
  const containerHeight = props.height;
  const start = Math.max(0, getStartIndex() - props.overscan);
  const end = Math.min(props.items.length - 1, getEndIndex() + props.overscan);
  
  const items: VirtualListItem[] = [];
  
  for (let i = start; i <= end; i++) {
    const position = itemPositions.value[i];
    if (position) {
      items.push({
        data: props.items[i],
        index: i,
        height: position.height,
        top: position.top
      });
    }
  }
  
  return items;
});

// 容器样式
const containerStyle = computed(() => ({
  height: props.height + 'px',
  overflow: 'hidden',
  position: 'relative'
}));

// 内容样式
const contentStyle = computed(() => ({
  height: '100%',
  overflow: 'auto',
  position: 'relative'
}));

// 获取项目唯一键
function getItemKey(item: VirtualListItem): string | number {
  if (props.keyField && item.data[props.keyField]) {
    return item.data[props.keyField];
  }
  return item.index;
}

// 获取项目样式
function getItemStyle(item: VirtualListItem) {
  return {
    position: 'absolute',
    top: item.top + 'px',
    left: '0',
    right: '0',
    height: item.height + 'px'
  };
}

// 获取开始索引
function getStartIndex(): number {
  let start = 0;
  let end = itemPositions.value.length - 1;
  
  while (start <= end) {
    const mid = Math.floor((start + end) / 2);
    const position = itemPositions.value[mid];
    
    if (position.top <= scrollTop.value && position.top + position.height > scrollTop.value) {
      return mid;
    } else if (position.top > scrollTop.value) {
      end = mid - 1;
    } else {
      start = mid + 1;
    }
  }
  
  return Math.max(0, end);
}

// 获取结束索引
function getEndIndex(): number {
  const startIndex = getStartIndex();
  let endIndex = startIndex;
  let currentHeight = 0;
  
  while (endIndex < itemPositions.value.length && currentHeight < props.height) {
    currentHeight += itemPositions.value[endIndex].height;
    endIndex++;
  }
  
  return Math.min(endIndex, itemPositions.value.length - 1);
}

// 初始化项目位置
function initializeItemPositions() {
  const positions: { top: number; height: number }[] = [];
  let top = 0;
  
  for (let i = 0; i < props.items.length; i++) {
    const height = typeof props.itemHeight === 'function' 
      ? props.itemHeight(props.items[i], i)
      : props.itemHeight;
    
    positions.push({ top, height });
    top += height;
  }
  
  itemPositions.value = positions;
}

// 处理滚动事件
const handleScroll = throttle((event: any) => {
  scrollTop.value = event.target.scrollTop || event.detail.scrollTop;
}, 16); // 60fps

// 更新项目高度（用于动态高度）
function updateItemHeight(index: number, height: number) {
  const oldHeight = itemPositions.value[index]?.height || 0;
  const deltaHeight = height - oldHeight;
  
  if (deltaHeight === 0) return;
  
  // 更新当前项目高度
  itemPositions.value[index].height = height;
  
  // 更新后续项目位置
  for (let i = index + 1; i < itemPositions.value.length; i++) {
    itemPositions.value[i].top += deltaHeight;
  }
}

// 滚动到指定索引
function scrollToIndex(index: number, align: 'start' | 'center' | 'end' = 'start') {
  if (index < 0 || index >= props.items.length) return;
  
  const position = itemPositions.value[index];
  if (!position) return;
  
  let targetScrollTop = position.top;
  
  if (align === 'center') {
    targetScrollTop = position.top - (props.height - position.height) / 2;
  } else if (align === 'end') {
    targetScrollTop = position.top - props.height + position.height;
  }
  
  targetScrollTop = Math.max(0, Math.min(targetScrollTop, totalHeight.value - props.height));
  
  if (containerRef.value) {
    containerRef.value.scrollTop = targetScrollTop;
  }
}

// 暴露方法
defineExpose({
  scrollToIndex,
  updateItemHeight
});

onMounted(() => {
  initializeItemPositions();
});

// 监听数据变化
watch(() => props.items, () => {
  nextTick(() => {
    initializeItemPositions();
  });
}, { deep: true });
</script>

<style lang="scss">
.u-virtual-list {
  position: relative;
  
  &__phantom {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    z-index: -1;
  }
  
  &__content {
    position: relative;
    z-index: 1;
  }
  
  &__item {
    box-sizing: border-box;
  }
}
</style>
```

### 1.2 懒加载组件

```typescript
// 懒加载指令
import { Directive, DirectiveBinding } from 'vue';

interface LazyElement extends HTMLElement {
  _lazyObserver?: IntersectionObserver;
  _lazyLoaded?: boolean;
}

class LazyLoadManager {
  private static instance: LazyLoadManager;
  private observer: IntersectionObserver | null = null;
  private elements: Map<Element, () => void> = new Map();
  
  static getInstance(): LazyLoadManager {
    if (!this.instance) {
      this.instance = new LazyLoadManager();
    }
    return this.instance;
  }
  
  constructor() {
    this.initObserver();
  }
  
  private initObserver() {
    // #ifdef H5
    if (typeof IntersectionObserver !== 'undefined') {
      this.observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              const callback = this.elements.get(entry.target);
              if (callback) {
                callback();
                this.unobserve(entry.target);
              }
            }
          });
        },
        {
          rootMargin: '50px',
          threshold: 0.1
        }
      );
    }
    // #endif
  }
  
  observe(element: Element, callback: () => void) {
    this.elements.set(element, callback);
    
    // #ifdef H5
    if (this.observer) {
      this.observer.observe(element);
    } else {
      // 降级方案：立即执行
      callback();
    }
    // #endif
    
    // #ifndef H5
    // 小程序和 App 使用滚动监听
    this.observeWithScroll(element, callback);
    // #endif
  }
  
  unobserve(element: Element) {
    this.elements.delete(element);
    
    // #ifdef H5
    if (this.observer) {
      this.observer.unobserve(element);
    }
    // #endif
  }
  
  private observeWithScroll(element: Element, callback: () => void) {
    // #ifndef H5
    // 使用 uni.createIntersectionObserver
    const observer = uni.createIntersectionObserver();
    observer.relativeToViewport({ bottom: 50 });
    observer.observe(element as any, (res: any) => {
      if (res.intersectionRatio > 0) {
        callback();
        observer.disconnect();
      }
    });
    // #endif
  }
  
  destroy() {
    // #ifdef H5
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
    }
    // #endif
    
    this.elements.clear();
  }
}

// 懒加载指令
export const vLazy: Directive = {
  mounted(el: LazyElement, binding: DirectiveBinding) {
    const manager = LazyLoadManager.getInstance();
    
    const callback = () => {
      if (typeof binding.value === 'function') {
        binding.value();
      } else if (binding.value && binding.value.src) {
        // 图片懒加载
        if (el.tagName === 'IMG') {
          (el as HTMLImageElement).src = binding.value.src;
        }
      }
      
      el._lazyLoaded = true;
    };
    
    manager.observe(el, callback);
  },
  
  unmounted(el: LazyElement) {
    const manager = LazyLoadManager.getInstance();
    manager.unobserve(el);
  }
};
```

### 1.3 防抖节流工具

```typescript
// 性能优化工具
export class PerformanceUtils {
  // 防抖函数
  static debounce<T extends (...args: any[]) => any>(
    func: T,
    wait: number,
    immediate: boolean = false
  ): (...args: Parameters<T>) => void {
    let timeout: any;
    
    return function executedFunction(...args: Parameters<T>) {
      const later = () => {
        timeout = null;
        if (!immediate) func(...args);
      };
      
      const callNow = immediate && !timeout;
      
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      
      if (callNow) func(...args);
    };
  }
  
  // 节流函数
  static throttle<T extends (...args: any[]) => any>(
    func: T,
    limit: number
  ): (...args: Parameters<T>) => void {
    let inThrottle: boolean;
    
    return function executedFunction(...args: Parameters<T>) {
      if (!inThrottle) {
        func(...args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }
  
  // RAF 节流
  static rafThrottle<T extends (...args: any[]) => any>(
    func: T
  ): (...args: Parameters<T>) => void {
    let rafId: number | null = null;
    
    return function executedFunction(...args: Parameters<T>) {
      if (rafId === null) {
        rafId = requestAnimationFrame(() => {
          func(...args);
          rafId = null;
        });
      }
    };
  }
  
  // 空闲时执行
  static idleCallback(callback: () => void, timeout: number = 5000) {
    // #ifdef H5
    if (typeof requestIdleCallback !== 'undefined') {
      requestIdleCallback(callback, { timeout });
    } else {
      setTimeout(callback, 0);
    }
    // #endif
    
    // #ifndef H5
    setTimeout(callback, 0);
    // #endif
  }
  
  // 批量更新
  static batchUpdate(updates: (() => void)[]): void {
    this.idleCallback(() => {
      updates.forEach(update => update());
    });
  }
  
  // 时间分片
  static timeSlicing<T>(
    tasks: T[],
    processor: (item: T) => void,
    timeSlice: number = 5
  ): Promise<void> {
    return new Promise((resolve) => {
      let index = 0;
      
      function processBatch() {
        const start = performance.now();
        
        while (index < tasks.length && performance.now() - start < timeSlice) {
          processor(tasks[index]);
          index++;
        }
        
        if (index < tasks.length) {
          // 还有任务，继续下一批
          setTimeout(processBatch, 0);
        } else {
          // 所有任务完成
          resolve();
        }
      }
      
      processBatch();
    });
  }
}

// 导出常用函数
export const { debounce, throttle, rafThrottle, idleCallback, batchUpdate, timeSlicing } = PerformanceUtils;
```

---

## 2. 内存管理优化

### 2.1 内存监控

```typescript
// 内存监控器
class MemoryMonitor {
  private static instance: MemoryMonitor;
  private observers: Set<any> = new Set();
  private timers: Set<any> = new Set();
  private eventListeners: Map<Element, Map<string, EventListener>> = new Map();
  private memoryThreshold: number = 50 * 1024 * 1024; // 50MB
  private checkInterval: any;
  
  static getInstance(): MemoryMonitor {
    if (!this.instance) {
      this.instance = new MemoryMonitor();
    }
    return this.instance;
  }
  
  constructor() {
    this.startMonitoring();
  }
  
  // 开始监控
  private startMonitoring() {
    this.checkInterval = setInterval(() => {
      this.checkMemoryUsage();
    }, 10000); // 每10秒检查一次
    
    this.registerTimer(this.checkInterval);
  }
  
  // 检查内存使用情况
  private checkMemoryUsage() {
    const memoryInfo = this.getMemoryInfo();
    
    if (memoryInfo && memoryInfo.used > this.memoryThreshold) {
      console.warn('Memory usage is high:', memoryInfo);
      this.triggerGarbageCollection();
    }
  }
  
  // 获取内存信息
  getMemoryInfo(): { used: number; total: number; limit: number } | null {
    // #ifdef H5
    if (performance && (performance as any).memory) {
      const memory = (performance as any).memory;
      return {
        used: memory.usedJSHeapSize,
        total: memory.totalJSHeapSize,
        limit: memory.jsHeapSizeLimit
      };
    }
    // #endif
    
    return null;
  }
  
  // 注册观察者
  registerObserver(observer: any) {
    this.observers.add(observer);
    
    // 返回清理函数
    return () => {
      this.unregisterObserver(observer);
    };
  }
  
  // 注销观察者
  unregisterObserver(observer: any) {
    this.observers.delete(observer);
    
    if (observer && typeof observer.disconnect === 'function') {
      observer.disconnect();
    }
  }
  
  // 注册定时器
  registerTimer(timer: any) {
    this.timers.add(timer);
    
    // 返回清理函数
    return () => {
      this.unregisterTimer(timer);
    };
  }
  
  // 注销定时器
  unregisterTimer(timer: any) {
    this.timers.delete(timer);
    clearTimeout(timer);
    clearInterval(timer);
  }
  
  // 注册事件监听器
  registerEventListener(
    element: Element,
    event: string,
    listener: EventListener,
    options?: boolean | AddEventListenerOptions
  ) {
    if (!this.eventListeners.has(element)) {
      this.eventListeners.set(element, new Map());
    }
    
    const elementListeners = this.eventListeners.get(element)!;
    elementListeners.set(event, listener);
    
    element.addEventListener(event, listener, options);
    
    // 返回清理函数
    return () => {
      this.unregisterEventListener(element, event);
    };
  }
  
  // 注销事件监听器
  unregisterEventListener(element: Element, event: string) {
    const elementListeners = this.eventListeners.get(element);
    if (elementListeners) {
      const listener = elementListeners.get(event);
      if (listener) {
        element.removeEventListener(event, listener);
        elementListeners.delete(event);
        
        if (elementListeners.size === 0) {
          this.eventListeners.delete(element);
        }
      }
    }
  }
  
  // 触发垃圾回收
  private triggerGarbageCollection() {
    // 清理无用的观察者
    this.cleanupObservers();
    
    // 清理无用的定时器
    this.cleanupTimers();
    
    // 清理无用的事件监听器
    this.cleanupEventListeners();
    
    // #ifdef H5
    // 强制垃圾回收（仅在开发环境）
    if (process.env.NODE_ENV === 'development' && (window as any).gc) {
      (window as any).gc();
    }
    // #endif
  }
  
  // 清理观察者
  private cleanupObservers() {
    const toRemove: any[] = [];
    
    this.observers.forEach(observer => {
      // 检查观察者是否还有效
      if (!observer || (observer.target && !document.contains(observer.target))) {
        toRemove.push(observer);
      }
    });
    
    toRemove.forEach(observer => {
      this.unregisterObserver(observer);
    });
  }
  
  // 清理定时器
  private cleanupTimers() {
    // 定时器通常需要手动清理，这里只是示例
    // 实际应用中应该在组件销毁时主动清理
  }
  
  // 清理事件监听器
  private cleanupEventListeners() {
    const toRemove: Element[] = [];
    
    this.eventListeners.forEach((listeners, element) => {
      if (!document.contains(element)) {
        toRemove.push(element);
      }
    });
    
    toRemove.forEach(element => {
      const listeners = this.eventListeners.get(element);
      if (listeners) {
        listeners.forEach((listener, event) => {
          element.removeEventListener(event, listener);
        });
        this.eventListeners.delete(element);
      }
    });
  }
  
  // 获取内存使用报告
  getMemoryReport(): {
    observers: number;
    timers: number;
    eventListeners: number;
    memoryInfo: any;
  } {
    return {
      observers: this.observers.size,
      timers: this.timers.size,
      eventListeners: this.eventListeners.size,
      memoryInfo: this.getMemoryInfo()
    };
  }
  
  // 销毁监控器
  destroy() {
    // 清理所有资源
    this.observers.forEach(observer => {
      if (observer && typeof observer.disconnect === 'function') {
        observer.disconnect();
      }
    });
    this.observers.clear();
    
    this.timers.forEach(timer => {
      clearTimeout(timer);
      clearInterval(timer);
    });
    this.timers.clear();
    
    this.eventListeners.forEach((listeners, element) => {
      listeners.forEach((listener, event) => {
        element.removeEventListener(event, listener);
      });
    });
    this.eventListeners.clear();
    
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
    }
  }
}

// 内存管理 Hook
export function useMemoryManagement() {
  const monitor = MemoryMonitor.getInstance();
  
  const registerObserver = (observer: any) => {
    return monitor.registerObserver(observer);
  };
  
  const registerTimer = (timer: any) => {
    return monitor.registerTimer(timer);
  };
  
  const registerEventListener = (
    element: Element,
    event: string,
    listener: EventListener,
    options?: boolean | AddEventListenerOptions
  ) => {
    return monitor.registerEventListener(element, event, listener, options);
  };
  
  const getMemoryReport = () => {
    return monitor.getMemoryReport();
  };
  
  return {
    registerObserver,
    registerTimer,
    registerEventListener,
    getMemoryReport
  };
}
```

### 2.2 对象池管理

```typescript
// 对象池
class ObjectPool<T> {
  private pool: T[] = [];
  private createFn: () => T;
  private resetFn?: (obj: T) => void;
  private maxSize: number;
  
  constructor(
    createFn: () => T,
    resetFn?: (obj: T) => void,
    maxSize: number = 100
  ) {
    this.createFn = createFn;
    this.resetFn = resetFn;
    this.maxSize = maxSize;
  }
  
  // 获取对象
  acquire(): T {
    if (this.pool.length > 0) {
      const obj = this.pool.pop()!;
      return obj;
    }
    
    return this.createFn();
  }
  
  // 释放对象
  release(obj: T): void {
    if (this.pool.length < this.maxSize) {
      if (this.resetFn) {
        this.resetFn(obj);
      }
      this.pool.push(obj);
    }
  }
  
  // 清空池
  clear(): void {
    this.pool.length = 0;
  }
  
  // 获取池大小
  size(): number {
    return this.pool.length;
  }
}

// 常用对象池
export class CommonObjectPools {
  // 数组对象池
  static arrayPool = new ObjectPool<any[]>(
    () => [],
    (arr) => { arr.length = 0; },
    50
  );
  
  // 对象池
  static objectPool = new ObjectPool<Record<string, any>>(
    () => ({}),
    (obj) => {
      for (const key in obj) {
        delete obj[key];
      }
    },
    50
  );
  
  // DOM 事件对象池
  static eventPool = new ObjectPool<{
    type: string;
    target: any;
    detail: any;
    timeStamp: number;
  }>(
    () => ({
      type: '',
      target: null,
      detail: null,
      timeStamp: 0
    }),
    (event) => {
      event.type = '';
      event.target = null;
      event.detail = null;
      event.timeStamp = 0;
    },
    30
  );
  
  // 获取临时数组
  static getTempArray<T>(): T[] {
    return this.arrayPool.acquire();
  }
  
  // 释放临时数组
  static releaseTempArray(arr: any[]): void {
    this.arrayPool.release(arr);
  }
  
  // 获取临时对象
  static getTempObject(): Record<string, any> {
    return this.objectPool.acquire();
  }
  
  // 释放临时对象
  static releaseTempObject(obj: Record<string, any>): void {
    this.objectPool.release(obj);
  }
  
  // 获取临时事件对象
  static getTempEvent(): {
    type: string;
    target: any;
    detail: any;
    timeStamp: number;
  } {
    return this.eventPool.acquire();
  }
  
  // 释放临时事件对象
  static releaseTempEvent(event: {
    type: string;
    target: any;
    detail: any;
    timeStamp: number;
  }): void {
    this.eventPool.release(event);
  }
}
```

---

## 3. 网络性能优化

### 3.1 请求缓存管理

```typescript
// 请求缓存管理器
class RequestCacheManager {
  private static instance: RequestCacheManager;
  private cache: Map<string, {
    data: any;
    timestamp: number;
    expiry: number;
  }> = new Map();
  private maxCacheSize: number = 100;
  private defaultExpiry: number = 5 * 60 * 1000; // 5分钟
  
  static getInstance(): RequestCacheManager {
    if (!this.instance) {
      this.instance = new RequestCacheManager();
    }
    return this.instance;
  }
  
  // 生成缓存键
  private generateKey(url: string, params?: any): string {
    const paramStr = params ? JSON.stringify(params) : '';
    return `${url}:${paramStr}`;
  }
  
  // 设置缓存
  set(url: string, params: any, data: any, expiry?: number): void {
    const key = this.generateKey(url, params);
    const expiryTime = expiry || this.defaultExpiry;
    
    // 如果缓存已满，删除最旧的条目
    if (this.cache.size >= this.maxCacheSize) {
      const oldestKey = this.cache.keys().next().value;
      this.cache.delete(oldestKey);
    }
    
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      expiry: expiryTime
    });
  }
  
  // 获取缓存
  get(url: string, params?: any): any | null {
    const key = this.generateKey(url, params);
    const cached = this.cache.get(key);
    
    if (!cached) {
      return null;
    }
    
    // 检查是否过期
    if (Date.now() - cached.timestamp > cached.expiry) {
      this.cache.delete(key);
      return null;
    }
    
    return cached.data;
  }
  
  // 删除缓存
  delete(url: string, params?: any): void {
    const key = this.generateKey(url, params);
    this.cache.delete(key);
  }
  
  // 清空缓存
  clear(): void {
    this.cache.clear();
  }
  
  // 清理过期缓存
  cleanup(): void {
    const now = Date.now();
    const toDelete: string[] = [];
    
    this.cache.forEach((value, key) => {
      if (now - value.timestamp > value.expiry) {
        toDelete.push(key);
      }
    });
    
    toDelete.forEach(key => {
      this.cache.delete(key);
    });
  }
  
  // 获取缓存统计
  getStats(): {
    size: number;
    maxSize: number;
    hitRate: number;
  } {
    return {
      size: this.cache.size,
      maxSize: this.maxCacheSize,
      hitRate: 0 // 需要额外统计
    };
  }
}

// HTTP 请求优化器
class HTTPOptimizer {
  private static instance: HTTPOptimizer;
  private cacheManager: RequestCacheManager;
  private pendingRequests: Map<string, Promise<any>> = new Map();
  private requestQueue: Array<{
    url: string;
    options: any;
    resolve: (value: any) => void;
    reject: (reason: any) => void;
  }> = [];
  private maxConcurrentRequests: number = 6;
  private activeRequests: number = 0;
  
  static getInstance(): HTTPOptimizer {
    if (!this.instance) {
      this.instance = new HTTPOptimizer();
    }
    return this.instance;
  }
  
  constructor() {
    this.cacheManager = RequestCacheManager.getInstance();
    
    // 定期清理过期缓存
    setInterval(() => {
      this.cacheManager.cleanup();
    }, 60000); // 每分钟清理一次
  }
  
  // 优化的请求方法
  async request(url: string, options: any = {}): Promise<any> {
    const cacheKey = this.generateRequestKey(url, options);
    
    // 检查缓存
    if (options.cache !== false) {
      const cached = this.cacheManager.get(url, options.data);
      if (cached) {
        return Promise.resolve(cached);
      }
    }
    
    // 检查是否有相同的请求正在进行
    if (this.pendingRequests.has(cacheKey)) {
      return this.pendingRequests.get(cacheKey)!;
    }
    
    // 创建请求 Promise
    const requestPromise = new Promise((resolve, reject) => {
      this.requestQueue.push({
        url,
        options,
        resolve,
        reject
      });
      
      this.processQueue();
    });
    
    this.pendingRequests.set(cacheKey, requestPromise);
    
    try {
      const result = await requestPromise;
      
      // 缓存结果
      if (options.cache !== false && options.method !== 'POST') {
        this.cacheManager.set(url, options.data, result, options.cacheExpiry);
      }
      
      return result;
    } finally {
      this.pendingRequests.delete(cacheKey);
    }
  }
  
  // 处理请求队列
  private async processQueue(): Promise<void> {
    if (this.activeRequests >= this.maxConcurrentRequests || this.requestQueue.length === 0) {
      return;
    }
    
    const request = this.requestQueue.shift();
    if (!request) return;
    
    this.activeRequests++;
    
    try {
      const result = await this.executeRequest(request.url, request.options);
      request.resolve(result);
    } catch (error) {
      request.reject(error);
    } finally {
      this.activeRequests--;
      this.processQueue(); // 处理下一个请求
    }
  }
  
  // 执行实际请求
  private async executeRequest(url: string, options: any): Promise<any> {
    // 这里可以根据平台选择不同的请求实现
    // #ifdef H5
    return this.fetchRequest(url, options);
    // #endif
    
    // #ifndef H5
    return this.uniRequest(url, options);
    // #endif
  }
  
  // H5 平台使用 fetch
  private async fetchRequest(url: string, options: any): Promise<any> {
    // #ifdef H5
    const response = await fetch(url, {
      method: options.method || 'GET',
      headers: options.headers || {},
      body: options.data ? JSON.stringify(options.data) : undefined
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    return response.json();
    // #endif
  }
  
  // 小程序和 App 使用 uni.request
  private async uniRequest(url: string, options: any): Promise<any> {
    // #ifndef H5
    return new Promise((resolve, reject) => {
      uni.request({
        url,
        method: options.method || 'GET',
        header: options.headers || {},
        data: options.data,
        success: (res: any) => {
          if (res.statusCode >= 200 && res.statusCode < 300) {
            resolve(res.data);
          } else {
            reject(new Error(`HTTP ${res.statusCode}`);
          }
        },
        fail: (error: any) => {
          reject(error);
        }
      });
    });
    // #endif
  }
  
  // 生成请求键
  private generateRequestKey(url: string, options: any): string {
    return `${options.method || 'GET'}:${url}:${JSON.stringify(options.data || {})}`;
  }
  
  // 预加载资源
  async preload(urls: string[]): Promise<void> {
    const promises = urls.map(url => 
      this.request(url, { cache: true, priority: 'low' })
        .catch(error => {
          console.warn(`Preload failed for ${url}:`, error);
        })
    );
    
    await Promise.allSettled(promises);
  }
  
  // 取消所有请求
  cancelAllRequests(): void {
    this.requestQueue.length = 0;
    this.pendingRequests.clear();
  }
}

// 导出优化的请求方法
export const optimizedRequest = HTTPOptimizer.getInstance().request.bind(HTTPOptimizer.getInstance());
export const preloadResources = HTTPOptimizer.getInstance().preload.bind(HTTPOptimizer.getInstance());
```

### 3.2 图片优化

```typescript
// 图片优化管理器
class ImageOptimizer {
  private static instance: ImageOptimizer;
  private imageCache: Map<string, HTMLImageElement | string> = new Map();
  private loadingImages: Map<string, Promise<HTMLImageElement | string>> = new Map();
  private maxCacheSize: number = 50;
  
  static getInstance(): ImageOptimizer {
    if (!this.instance) {
      this.instance = new ImageOptimizer();
    }
    return this.instance;
  }
  
  // 加载图片
  async loadImage(src: string, options: {
    width?: number;
    height?: number;
    quality?: number;
    format?: 'webp' | 'jpeg' | 'png';
    lazy?: boolean;
  } = {}): Promise<HTMLImageElement | string> {
    const cacheKey = this.generateCacheKey(src, options);
    
    // 检查缓存
    if (this.imageCache.has(cacheKey)) {
      return this.imageCache.get(cacheKey)!;
    }
    
    // 检查是否正在加载
    if (this.loadingImages.has(cacheKey)) {
      return this.loadingImages.get(cacheKey)!;
    }
    
    // 开始加载
    const loadPromise = this.performImageLoad(src, options);
    this.loadingImages.set(cacheKey, loadPromise);
    
    try {
      const result = await loadPromise;
      
      // 缓存结果
      if (this.imageCache.size >= this.maxCacheSize) {
        const firstKey = this.imageCache.keys().next().value;
        this.imageCache.delete(firstKey);
      }
      
      this.imageCache.set(cacheKey, result);
      return result;
    } finally {
      this.loadingImages.delete(cacheKey);
    }
  }
  
  // 执行图片加载
  private async performImageLoad(
    src: string,
    options: any
  ): Promise<HTMLImageElement | string> {
    // 优化图片 URL
    const optimizedSrc = this.optimizeImageUrl(src, options);
    
    // #ifdef H5
    return this.loadImageH5(optimizedSrc);
    // #endif
    
    // #ifndef H5
    return optimizedSrc; // 小程序和 App 直接返回 URL
    // #endif
  }
  
  // H5 平台图片加载
  private loadImageH5(src: string): Promise<HTMLImageElement> {
    // #ifdef H5
    return new Promise((resolve, reject) => {
      const img = new Image();
      
      img.onload = () => resolve(img);
      img.onerror = () => reject(new Error(`Failed to load image: ${src}`));
      
      // 设置跨域
      img.crossOrigin = 'anonymous';
      img.src = src;
    });
    // #endif
  }
  
  // 优化图片 URL
  private optimizeImageUrl(src: string, options: any): string {
    if (!src) return src;
    
    // 如果是 base64 或 blob URL，直接返回
    if (src.startsWith('data:') || src.startsWith('blob:')) {
      return src;
    }
    
    // 构建优化参数
    const params: string[] = [];
    
    if (options.width) {
      params.push(`w=${options.width}`);
    }
    
    if (options.height) {
      params.push(`h=${options.height}`);
    }
    
    if (options.quality) {
      params.push(`q=${options.quality}`);
    }
    
    if (options.format) {
      params.push(`f=${options.format}`);
    }
    
    // 添加设备像素比
    // #ifdef H5
    const dpr = window.devicePixelRatio || 1;
    if (dpr > 1) {
      params.push(`dpr=${Math.min(dpr, 3)}`);
    }
    // #endif
    
    // 如果有参数，添加到 URL
    if (params.length > 0) {
      const separator = src.includes('?') ? '&' : '?';
      return `${src}${separator}${params.join('&')}`;
    }
    
    return src;
  }
  
  // 生成缓存键
  private generateCacheKey(src: string, options: any): string {
    return `${src}:${JSON.stringify(options)}`;
  }
  
  // 预加载图片
  async preloadImages(srcs: string[], options: any = {}): Promise<void> {
    const promises = srcs.map(src => 
      this.loadImage(src, options)
        .catch(error => {
          console.warn(`Failed to preload image ${src}:`, error);
        })
    );
    
    await Promise.allSettled(promises);
  }
  
  // 清理缓存
  clearCache(): void {
    this.imageCache.clear();
    this.loadingImages.clear();
  }
  
  // 获取缓存统计
  getCacheStats(): {
    cacheSize: number;
    maxCacheSize: number;
    loadingCount: number;
  } {
    return {
      cacheSize: this.imageCache.size,
      maxCacheSize: this.maxCacheSize,
      loadingCount: this.loadingImages.size
    };
  }
}

// 图片懒加载组件
export const ImageLazy = defineComponent({
  name: 'ImageLazy',
  props: {
    src: String,
    width: Number,
    height: Number,
    quality: Number,
    format: String as PropType<'webp' | 'jpeg' | 'png'>,
    placeholder: String,
    errorImage: String,
    lazy: {
      type: Boolean,
      default: true
    }
  },
  setup(props) {
    const imageRef = ref<HTMLElement>();
    const imageSrc = ref(props.placeholder || '');
    const isLoading = ref(true);
    const hasError = ref(false);
    const optimizer = ImageOptimizer.getInstance();
    
    const loadImage = async () => {
      if (!props.src) return;
      
      try {
        isLoading.value = true;
        hasError.value = false;
        
        const result = await optimizer.loadImage(props.src, {
          width: props.width,
          height: props.height,
          quality: props.quality,
          format: props.format
        });
        
        // #ifdef H5
        if (result instanceof HTMLImageElement) {
          imageSrc.value = result.src;
        } else {
          imageSrc.value = result;
        }
        // #endif
        
        // #ifndef H5
        imageSrc.value = result as string;
        // #endif
        
      } catch (error) {
        console.error('Failed to load image:', error);
        hasError.value = true;
        
        if (props.errorImage) {
          imageSrc.value = props.errorImage;
        }
      } finally {
        isLoading.value = false;
      }
    };
    
    onMounted(() => {
      if (props.lazy && imageRef.value) {
        // 使用懒加载
        const observer = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                loadImage();
                observer.unobserve(entry.target);
              }
            });
          },
          { threshold: 0.1 }
        );
        
        observer.observe(imageRef.value);
        
        onUnmounted(() => {
          observer.disconnect();
        });
      } else {
        // 立即加载
        loadImage();
      }
    });
    
    return {
      imageRef,
      imageSrc,
      isLoading,
      hasError
    };
  },
  render() {
    return h('img', {
      ref: 'imageRef',
      src: this.imageSrc,
      class: {
        'u-image-lazy': true,
        'u-image-lazy--loading': this.isLoading,
        'u-image-lazy--error': this.hasError
      },
      style: {
        width: this.width ? `${this.width}px` : undefined,
        height: this.height ? `${this.height}px` : undefined
      }
    });
  }
});
```

---

## 4. 包体积优化

### 4.1 Tree Shaking 配置

```javascript
// rollup.config.js
import { defineConfig } from 'rollup';
import typescript from '@rollup/plugin-typescript';
import { terser } from 'rollup-plugin-terser';
import analyze from 'rollup-plugin-analyzer';

export default defineConfig({
  input: 'src/index.ts',
  output: [
    {
      file: 'dist/index.esm.js',
      format: 'esm',
      sourcemap: true
    },
    {
      file: 'dist/index.cjs.js',
      format: 'cjs',
      sourcemap: true
    },
    {
      file: 'dist/index.umd.js',
      format: 'umd',
      name: 'UKit',
      sourcemap: true
    }
  ],
  plugins: [
    typescript({
      declaration: true,
      declarationDir: 'dist/types'
    }),
    terser({
      compress: {
        drop_console: true,
        drop_debugger: true,
        pure_funcs: ['console.log', 'console.warn']
      },
      mangle: {
        reserved: ['UKit']
      }
    }),
    analyze({
      summaryOnly: true,
      limit: 10
    })
  ],
  external: [
    'vue',
    '@dcloudio/uni-app'
  ],
  treeshake: {
    moduleSideEffects: false,
    propertyReadSideEffects: false,
    unknownGlobalSideEffects: false
  }
});
```

### 4.2 按需加载配置

```typescript
// 按需加载插件
interface ImportOptions {
  libraryName: string;
  libraryDirectory?: string;
  style?: boolean | string;
  camel2DashComponentName?: boolean;
}

class BabelPluginImport {
  private options: ImportOptions;
  
  constructor(options: ImportOptions) {
    this.options = {
      libraryDirectory: 'lib',
      style: true,
      camel2DashComponentName: true,
      ...options
    };
  }
  
  // 转换导入语句
  transformImport(importPath: string, importName: string): {
    componentPath: string;
    stylePath?: string;
  } {
    const { libraryName, libraryDirectory, style, camel2DashComponentName } = this.options;
    
    if (importPath !== libraryName) {
      return { componentPath: importPath };
    }
    
    // 转换组件名
    let componentName = importName;
    if (camel2DashComponentName) {
      componentName = this.camel2Dash(importName);
    }
    
    // 生成组件路径
    const componentPath = `${libraryName}/${libraryDirectory}/${componentName}`;
    
    // 生成样式路径
    let stylePath: string | undefined;
    if (style === true) {
      stylePath = `${componentPath}/style`;
    } else if (typeof style === 'string') {
      stylePath = `${componentPath}/${style}`;
    }
    
    return {
      componentPath,
      stylePath
    };
  }
  
  // 驼峰转短横线
  private camel2Dash(str: string): string {
    return str.replace(/([A-Z])/g, '-$1').toLowerCase().replace(/^-/, '');
  }
}

// Vite 插件
export function vitePluginImport(options: ImportOptions) {
  const plugin = new BabelPluginImport(options);
  
  return {
    name: 'vite-plugin-import',
    transform(code: string, id: string) {
      if (!id.endsWith('.vue') && !id.endsWith('.ts') && !id.endsWith('.js')) {
        return null;
      }
      
      // 匹配 import 语句
      const importRegex = /import\s+{([^}]+)}\s+from\s+['"]([^'"]+)['"]/g;
      let transformedCode = code;
      let match;
      
      while ((match = importRegex.exec(code)) !== null) {
        const [fullMatch, imports, importPath] = match;
        
        if (importPath === options.libraryName) {
          const importNames = imports.split(',').map(name => name.trim());
          const transformedImports: string[] = [];
          
          importNames.forEach(importName => {
            const { componentPath, stylePath } = plugin.transformImport(importPath, importName);
            
            transformedImports.push(`import ${importName} from '${componentPath}';`);
            
            if (stylePath) {
              transformedImports.push(`import '${stylePath}';`);
            }
          });
          
          transformedCode = transformedCode.replace(fullMatch, transformedImports.join('\n'));
        }
      }
      
      return {
        code: transformedCode,
        map: null
      };
    }
  };
}
```

### 4.3 代码分割策略

```typescript
// 动态导入管理器
class DynamicImportManager {
  private static instance: DynamicImportManager;
  private loadedModules: Map<string, any> = new Map();
  private loadingModules: Map<string, Promise<any>> = new Map();
  
  static getInstance(): DynamicImportManager {
    if (!this.instance) {
      this.instance = new DynamicImportManager();
    }
    return this.instance;
  }
  
  // 动态加载组件
  async loadComponent(componentName: string): Promise<any> {
    // 检查是否已加载
    if (this.loadedModules.has(componentName)) {
      return this.loadedModules.get(componentName);
    }
    
    // 检查是否正在加载
    if (this.loadingModules.has(componentName)) {
      return this.loadingModules.get(componentName);
    }
    
    // 开始加载
    const loadPromise = this.performDynamicImport(componentName);
    this.loadingModules.set(componentName, loadPromise);
    
    try {
      const module = await loadPromise;
      this.loadedModules.set(componentName, module);
      return module;
    } finally {
      this.loadingModules.delete(componentName);
    }
  }
  
  // 执行动态导入
  private async performDynamicImport(componentName: string): Promise<any> {
    const componentMap: Record<string, () => Promise<any>> = {
      // 基础组件
      'UButton': () => import('../components/button/index.vue'),
      'UInput': () => import('../components/input/index.vue'),
      'UCard': () => import('../components/card/index.vue'),
      
      // 表单组件
      'UForm': () => import('../components/form/index.vue'),
      'UFormItem': () => import('../components/form-item/index.vue'),
      'UCheckbox': () => import('../components/checkbox/index.vue'),
      'URadio': () => import('../components/radio/index.vue'),
      'USwitch': () => import('../components/switch/index.vue'),
      
      // 导航组件
      'UTabbar': () => import('../components/tabbar/index.vue'),
      'UNavbar': () => import('../components/navbar/index.vue'),
      'UBreadcrumb': () => import('../components/breadcrumb/index.vue'),
      
      // 反馈组件
      'UModal': () => import('../components/modal/index.vue'),
      'UToast': () => import('../components/toast/index.vue'),
      'ULoading': () => import('../components/loading/index.vue'),
      'UAlert': () => import('../components/alert/index.vue'),
      
      // 展示组件
      'UList': () => import('../components/list/index.vue'),
      'UGrid': () => import('../components/grid/index.vue'),
      'USwiper': () => import('../components/swiper/index.vue'),
      'UImage': () => import('../components/image/index.vue'),
      'UAvatar': () => import('../components/avatar/index.vue'),
      'UTag': () => import('../components/tag/index.vue'),
      'UBadge': () => import('../components/badge/index.vue'),
      
      // 高级组件
      'UVirtualList': () => import('../components/virtual-list/index.vue'),
      'UInfiniteScroll': () => import('../components/infinite-scroll/index.vue'),
      'UPullRefresh': () => import('../components/pull-refresh/index.vue'),
      'UCalendar': () => import('../components/calendar/index.vue'),
      'UDatePicker': () => import('../components/date-picker/index.vue'),
      'UTimePicker': () => import('../components/time-picker/index.vue'),
      'UPicker': () => import('../components/picker/index.vue'),
      'UActionSheet': () => import('../components/action-sheet/index.vue'),
      'UPopup': () => import('../components/popup/index.vue'),
      'UDropdown': () => import('../components/dropdown/index.vue'),
      
      // 业务组件
      'USearch': () => import('../components/search/index.vue'),
      'UIndexList': () => import('../components/index-list/index.vue'),
      'USteps': () => import('../components/steps/index.vue'),
      'UProgress': () => import('../components/progress/index.vue'),
      'URate': () => import('../components/rate/index.vue'),
      'USlider': () => import('../components/slider/index.vue'),
      'UUpload': () => import('../components/upload/index.vue'),
      'UCountdown': () => import('../components/countdown/index.vue'),
      'UNoticeBar': () => import('../components/notice-bar/index.vue')
    };
    
    const importFn = componentMap[componentName];
    if (!importFn) {
      throw new Error(`Component ${componentName} not found`);
    }
    
    const module = await importFn();
    return module.default || module;
  }
  
  // 预加载组件
  async preloadComponents(componentNames: string[]): Promise<void> {
    const promises = componentNames.map(name => 
      this.loadComponent(name).catch(error => {
        console.warn(`Failed to preload component ${name}:`, error);
      })
    );
    
    await Promise.allSettled(promises);
  }
  
  // 获取已加载的组件列表
  getLoadedComponents(): string[] {
    return Array.from(this.loadedModules.keys());
  }
  
  // 清理缓存
  clearCache(): void {
    this.loadedModules.clear();
    this.loadingModules.clear();
  }
}

// 异步组件包装器
export function defineAsyncComponent(componentName: string) {
  const manager = DynamicImportManager.getInstance();
  
  return defineAsyncComponent({
    loader: () => manager.loadComponent(componentName),
    loadingComponent: {
      template: '<div class="u-loading">Loading...</div>'
    },
    errorComponent: {
      template: '<div class="u-error">Failed to load component</div>'
    },
    delay: 200,
    timeout: 10000
  });
}
```

---

## 5. 性能监控与分析

### 5.1 性能指标收集

```typescript
// 性能指标收集器
class PerformanceCollector {
  private static instance: PerformanceCollector;
  private metrics: Map<string, any[]> = new Map();
  private observers: PerformanceObserver[] = [];
  
  static getInstance(): PerformanceCollector {
    if (!this.instance) {
      this.instance = new PerformanceCollector();
    }
    return this.instance;
  }
  
  constructor() {
    this.initObservers();
  }
  
  // 初始化性能观察者
  private initObservers() {
    // #ifdef H5
    if (typeof PerformanceObserver !== 'undefined') {
      // 观察导航时间
      this.observeNavigation();
      
      // 观察资源加载时间
      this.observeResources();
      
      // 观察长任务
      this.observeLongTasks();
      
      // 观察布局偏移
      this.observeLayoutShift();
      
      // 观察首次内容绘制
      this.observePaint();
    }
    // #endif
  }
  
  // 观察导航性能
  private observeNavigation() {
    // #ifdef H5
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      entries.forEach((entry: any) => {
        this.recordMetric('navigation', {
          type: entry.type,
          domContentLoaded: entry.domContentLoadedEventEnd - entry.domContentLoadedEventStart,
          loadComplete: entry.loadEventEnd - entry.loadEventStart,
          domInteractive: entry.domInteractive - entry.navigationStart,
          firstByte: entry.responseStart - entry.navigationStart
        });
      });
    });
    
    observer.observe({ entryTypes: ['navigation'] });
    this.observers.push(observer);
    // #endif
  }
  
  // 观察资源加载
  private observeResources() {
    // #ifdef H5
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      entries.forEach((entry: any) => {
        this.recordMetric('resource', {
          name: entry.name,
          type: entry.initiatorType,
          size: entry.transferSize,
          duration: entry.duration,
          startTime: entry.startTime
        });
      });
    });
    
    observer.observe({ entryTypes: ['resource'] });
    this.observers.push(observer);
    // #endif
  }
  
  // 观察长任务
  private observeLongTasks() {
    // #ifdef H5
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      entries.forEach((entry: any) => {
        this.recordMetric('longtask', {
          duration: entry.duration,
          startTime: entry.startTime,
          attribution: entry.attribution
        });
      });
    });
    
    observer.observe({ entryTypes: ['longtask'] });
    this.observers.push(observer);
    // #endif
  }
  
  // 观察布局偏移
  private observeLayoutShift() {
    // #ifdef H5
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      entries.forEach((entry: any) => {
        this.recordMetric('layout-shift', {
          value: entry.value,
          hadRecentInput: entry.hadRecentInput,
          startTime: entry.startTime
        });
      });
    });
    
    observer.observe({ entryTypes: ['layout-shift'] });
    this.observers.push(observer);
    // #endif
  }
  
  // 观察绘制性能
  private observePaint() {
    // #ifdef H5
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      entries.forEach((entry: any) => {
        this.recordMetric('paint', {
          name: entry.name,
          startTime: entry.startTime
        });
      });
    });
    
    observer.observe({ entryTypes: ['paint'] });
    this.observers.push(observer);
    // #endif
  }
  
  // 记录指标
  recordMetric(type: string, data: any) {
    if (!this.metrics.has(type)) {
      this.metrics.set(type, []);
    }
    
    const metrics = this.metrics.get(type)!;
    metrics.push({
      ...data,
      timestamp: Date.now()
    });
    
    // 限制存储数量
    if (metrics.length > 100) {
      metrics.shift();
    }
  }
  
  // 获取性能报告
  getPerformanceReport(): {
    navigation: any[];
    resources: any[];
    longTasks: any[];
    layoutShifts: any[];
    paint: any[];
    memory: any;
    timing: any;
  } {
    return {
      navigation: this.metrics.get('navigation') || [],
      resources: this.metrics.get('resource') || [],
      longTasks: this.metrics.get('longtask') || [],
      layoutShifts: this.metrics.get('layout-shift') || [],
      paint: this.metrics.get('paint') || [],
      memory: this.getMemoryInfo(),
      timing: this.getTimingInfo()
    };
  }
  
  // 获取内存信息
  private getMemoryInfo(): any {
    // #ifdef H5
    if (performance && (performance as any).memory) {
      const memory = (performance as any).memory;
      return {
        used: memory.usedJSHeapSize,
        total: memory.totalJSHeapSize,
        limit: memory.jsHeapSizeLimit
      };
    }
    // #endif
    
    return null;
  }
  
  // 获取时间信息
  private getTimingInfo(): any {
    // #ifdef H5
    if (performance && performance.timing) {
      const timing = performance.timing;
      return {
        navigationStart: timing.navigationStart,
        domContentLoaded: timing.domContentLoadedEventEnd - timing.navigationStart,
        loadComplete: timing.loadEventEnd - timing.navigationStart,
        firstByte: timing.responseStart - timing.navigationStart,
        domReady: timing.domInteractive - timing.navigationStart
      };
    }
    // #endif
    
    return null;
  }
  
  // 计算核心 Web 指标
  getCoreWebVitals(): {
    lcp?: number; // Largest Contentful Paint
    fid?: number; // First Input Delay
    cls?: number; // Cumulative Layout Shift
    fcp?: number; // First Contentful Paint
    ttfb?: number; // Time to First Byte
  } {
    const paint = this.metrics.get('paint') || [];
    const layoutShifts = this.metrics.get('layout-shift') || [];
    const timing = this.getTimingInfo();
    
    const result: any = {};
    
    // First Contentful Paint
    const fcp = paint.find(p => p.name === 'first-contentful-paint');
    if (fcp) {
      result.fcp = fcp.startTime;
    }
    
    // Cumulative Layout Shift
    if (layoutShifts.length > 0) {
      result.cls = layoutShifts
        .filter(shift => !shift.hadRecentInput)
        .reduce((sum, shift) => sum + shift.value, 0);
    }
    
    // Time to First Byte
    if (timing && timing.firstByte) {
      result.ttfb = timing.firstByte;
    }
    
    return result;
  }
  
  // 清理观察者
  destroy() {
    this.observers.forEach(observer => {
      observer.disconnect();
    });
    this.observers.length = 0;
    this.metrics.clear();
  }
}
```

### 5.2 性能分析工具

```typescript
// 性能分析器
class PerformanceAnalyzer {
  private static instance: PerformanceAnalyzer;
  private collector: PerformanceCollector;
  
  static getInstance(): PerformanceAnalyzer {
    if (!this.instance) {
      this.instance = new PerformanceAnalyzer();
    }
    return this.instance;
  }
  
  constructor() {
    this.collector = PerformanceCollector.getInstance();
  }
  
  // 分析组件渲染性能
  analyzeComponentPerformance(componentName: string): {
    renderTime: number;
    updateTime: number;
    memoryUsage: number;
    recommendations: string[];
  } {
    const startTime = performance.now();
    
    // 模拟组件分析
    const renderTime = this.measureRenderTime(componentName);
    const updateTime = this.measureUpdateTime(componentName);
    const memoryUsage = this.measureMemoryUsage(componentName);
    
    const recommendations = this.generateRecommendations({
      renderTime,
      updateTime,
      memoryUsage
    });
    
    return {
      renderTime,
      updateTime,
      memoryUsage,
      recommendations
    };
  }
  
  // 测量渲染时间
  private measureRenderTime(componentName: string): number {
    // 实际实现中，这里会测量组件的实际渲染时间
    const longTasks = this.collector.getPerformanceReport().longTasks;
    const recentTasks = longTasks.filter(task => 
      Date.now() - task.timestamp < 5000
    );
    
    return recentTasks.reduce((sum, task) => sum + task.duration, 0);
  }
  
  // 测量更新时间
  private measureUpdateTime(componentName: string): number {
    // 实际实现中，这里会测量组件的更新时间
    return Math.random() * 10; // 模拟数据
  }
  
  // 测量内存使用
  private measureMemoryUsage(componentName: string): number {
    const memoryInfo = this.collector.getPerformanceReport().memory;
    return memoryInfo ? memoryInfo.used : 0;
  }
  
  // 生成优化建议
  private generateRecommendations(metrics: {
    renderTime: number;
    updateTime: number;
    memoryUsage: number;
  }): string[] {
    const recommendations: string[] = [];
    
    if (metrics.renderTime > 16) {
      recommendations.push('渲染时间过长，考虑使用虚拟滚动或懒加载');
    }
    
    if (metrics.updateTime > 5) {
      recommendations.push('更新时间过长，检查是否有不必要的重新渲染');
    }
    
    if (metrics.memoryUsage > 50 * 1024 * 1024) {
      recommendations.push('内存使用过高，检查是否有内存泄漏');
    }
    
    return recommendations;
  }
  
  // 分析页面性能
  analyzePagePerformance(): {
    score: number;
    metrics: any;
    issues: string[];
    suggestions: string[];
  } {
    const report = this.collector.getPerformanceReport();
    const coreVitals = this.collector.getCoreWebVitals();
    
    const score = this.calculatePerformanceScore(coreVitals);
    const issues = this.identifyPerformanceIssues(report, coreVitals);
    const suggestions = this.generatePageSuggestions(issues);
    
    return {
      score,
      metrics: { ...report, coreVitals },
      issues,
      suggestions
    };
  }
  
  // 计算性能分数
  private calculatePerformanceScore(coreVitals: any): number {
    let score = 100;
    
    // FCP 评分
    if (coreVitals.fcp) {
      if (coreVitals.fcp > 3000) score -= 20;
      else if (coreVitals.fcp > 1800) score -= 10;
    }
    
    // CLS 评分
    if (coreVitals.cls) {
      if (coreVitals.cls > 0.25) score -= 20;
      else if (coreVitals.cls > 0.1) score -= 10;
    }
    
    // TTFB 评分
    if (coreVitals.ttfb) {
      if (coreVitals.ttfb > 800) score -= 15;
      else if (coreVitals.ttfb > 600) score -= 8;
    }
    
    return Math.max(0, score);
  }
  
  // 识别性能问题
  private identifyPerformanceIssues(report: any, coreVitals: any): string[] {
    const issues: string[] = [];
    
    // 检查长任务
    if (report.longTasks.length > 0) {
      issues.push(`发现 ${report.longTasks.length} 个长任务`);
    }
    
    // 检查大资源
    const largeResources = report.resources.filter((r: any) => r.size > 1024 * 1024);
    if (largeResources.length > 0) {
      issues.push(`发现 ${largeResources.length} 个大于 1MB 的资源`);
    }
    
    // 检查布局偏移
    if (coreVitals.cls > 0.1) {
      issues.push('累积布局偏移过大');
    }
    
    // 检查首次内容绘制
    if (coreVitals.fcp > 1800) {
      issues.push('首次内容绘制时间过长');
    }
    
    return issues;
  }
  
  // 生成页面优化建议
  private generatePageSuggestions(issues: string[]): string[] {
    const suggestions: string[] = [];
    
    issues.forEach(issue => {
      if (issue.includes('长任务')) {
        suggestions.push('使用时间分片技术拆分长任务');
        suggestions.push('考虑使用 Web Workers 处理计算密集型任务');
      }
      
      if (issue.includes('大资源')) {
        suggestions.push('压缩和优化图片资源');
        suggestions.push('使用 CDN 加速资源加载');
        suggestions.push('实施资源懒加载');
      }
      
      if (issue.includes('布局偏移')) {
        suggestions.push('为图片和视频设置明确的尺寸');
        suggestions.push('避免在现有内容上方插入内容');
      }
      
      if (issue.includes('首次内容绘制')) {
        suggestions.push('优化关键渲染路径');
        suggestions.push('减少阻塞渲染的资源');
        suggestions.push('使用服务端渲染或预渲染');
      }
    });
    
    return [...new Set(suggestions)]; // 去重
  }
  
  // 生成性能报告
  generateReport(): {
    summary: any;
    details: any;
    recommendations: string[];
    timestamp: number;
  } {
    const pageAnalysis = this.analyzePagePerformance();
    
    return {
      summary: {
        score: pageAnalysis.score,
        coreVitals: pageAnalysis.metrics.coreVitals,
        issueCount: pageAnalysis.issues.length
      },
      details: pageAnalysis.metrics,
      recommendations: pageAnalysis.suggestions,
      timestamp: Date.now()
    };
  }
}

// 性能监控 Hook
export function usePerformanceMonitoring() {
  const analyzer = PerformanceAnalyzer.getInstance();
  
  const analyzeComponent = (componentName: string) => {
    return analyzer.analyzeComponentPerformance(componentName);
  };
  
  const analyzePage = () => {
    return analyzer.analyzePagePerformance();
  };
  
  const generateReport = () => {
    return analyzer.generateReport();
  };
  
  return {
    analyzeComponent,
    analyzePage,
    generateReport
  };
}
```

---

## 6. 最佳实践总结

### 6.1 开发阶段优化

1. **组件设计**
   - 保持组件单一职责
   - 合理使用 props 和 slots
   - 避免深层嵌套
   - 使用 TypeScript 提供类型安全

2. **状态管理**
   - 最小化响应式数据
   - 使用 computed 缓存计算结果
   - 合理使用 watch 和 watchEffect
   - 避免不必要的深度监听

3. **事件处理**
   - 使用防抖和节流
   - 及时移除事件监听器
   - 避免在模板中使用复杂表达式

### 6.2 构建阶段优化

1. **代码分割**
   - 按路由分割
   - 按功能模块分割
   - 动态导入非关键组件

2. **资源优化**
   - 压缩 JavaScript 和 CSS
   - 优化图片资源
   - 使用 Tree Shaking
   - 移除未使用的代码

3. **缓存策略**
   - 设置合适的缓存头
   - 使用版本号或哈希
   - 实施增量更新

### 6.3 运行时优化

1. **渲染优化**
   - 使用虚拟滚动
   - 实施懒加载
   - 避免强制同步布局

2. **内存管理**
   - 及时清理定时器
   - 移除 DOM 事件监听器
   - 使用对象池复用对象

3. **网络优化**
   - 实施请求缓存
   - 使用请求去重
   - 预加载关键资源

通过以上性能优化策略，u-kit 组件库能够在各个平台上提供流畅、高效的用户体验，同时保持良好的开发体验和可维护性。
