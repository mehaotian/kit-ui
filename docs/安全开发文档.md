# u-kit 组件库安全开发文档

## 概述

本文档详细阐述了 u-kit 组件库在开发过程中需要遵循的安全规范和最佳实践，确保组件库的安全性和用户数据的保护。

---

## 1. 输入验证与过滤

### 1.1 XSS 防护

#### 1.1.1 HTML 内容过滤

```typescript
// utils/security.ts

/**
 * HTML 内容安全过滤器
 */
export class HTMLSanitizer {
  private static readonly ALLOWED_TAGS = [
    'p', 'br', 'strong', 'em', 'u', 'span', 'div',
    'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
    'ul', 'ol', 'li', 'blockquote'
  ];
  
  private static readonly ALLOWED_ATTRIBUTES = {
    '*': ['class', 'id'],
    'a': ['href', 'title', 'target'],
    'img': ['src', 'alt', 'width', 'height']
  };
  
  private static readonly DANGEROUS_PROTOCOLS = [
    'javascript:',
    'data:',
    'vbscript:',
    'file:',
    'about:'
  ];
  
  /**
   * 清理 HTML 内容
   * @param html 原始 HTML 内容
   * @returns 清理后的安全 HTML 内容
   */
  static sanitize(html: string): string {
    if (!html || typeof html !== 'string') {
      return '';
    }
    
    // 移除危险的协议
    let cleanHtml = html;
    this.DANGEROUS_PROTOCOLS.forEach(protocol => {
      const regex = new RegExp(protocol, 'gi');
      cleanHtml = cleanHtml.replace(regex, '');
    });
    
    // 移除 script 标签
    cleanHtml = cleanHtml.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '');
    
    // 移除事件处理器
    cleanHtml = cleanHtml.replace(/on\w+\s*=\s*["'][^"']*["']/gi, '');
    
    // 移除 style 属性中的危险内容
    cleanHtml = cleanHtml.replace(
      /style\s*=\s*["']([^"']*)["']/gi,
      (match, styleContent) => {
        const safeStyle = this.sanitizeStyle(styleContent);
        return safeStyle ? `style="${safeStyle}"` : '';
      }
    );
    
    return cleanHtml;
  }
  
  /**
   * 清理 CSS 样式内容
   * @param style CSS 样式字符串
   * @returns 清理后的安全 CSS 样式
   */
  private static sanitizeStyle(style: string): string {
    if (!style) return '';
    
    // 移除危险的 CSS 函数
    const dangerousFunctions = [
      'expression',
      'javascript',
      'vbscript',
      'import',
      'url\\(',
      '@import'
    ];
    
    let cleanStyle = style;
    dangerousFunctions.forEach(func => {
      const regex = new RegExp(func, 'gi');
      cleanStyle = cleanStyle.replace(regex, '');
    });
    
    return cleanStyle;
  }
  
  /**
   * 转义 HTML 特殊字符
   * @param text 原始文本
   * @returns 转义后的文本
   */
  static escapeHtml(text: string): string {
    if (!text || typeof text !== 'string') {
      return '';
    }
    
    const escapeMap: Record<string, string> = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '/': '&#x2F;'
    };
    
    return text.replace(/[&<>"'\/]/g, char => escapeMap[char]);
  }
}

// 在组件中使用
// components/rich-text/index.vue
<template>
  <view class="u-rich-text">
    <view v-html="sanitizedContent"></view>
  </view>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { HTMLSanitizer } from '../../utils/security';

interface Props {
  content: string;
  allowUnsafe?: boolean;
}

const props = withDefaults(defineProps<Props>(), {
  content: '',
  allowUnsafe: false
});

const sanitizedContent = computed(() => {
  if (props.allowUnsafe) {
    console.warn('u-rich-text: allowUnsafe is enabled, content will not be sanitized');
    return props.content;
  }
  
  return HTMLSanitizer.sanitize(props.content);
});
</script>
```

#### 1.1.2 URL 验证

```typescript
// utils/url-validator.ts

/**
 * URL 安全验证器
 */
export class URLValidator {
  private static readonly ALLOWED_PROTOCOLS = ['http:', 'https:', 'mailto:', 'tel:'];
  private static readonly DANGEROUS_PATTERNS = [
    /javascript:/i,
    /data:/i,
    /vbscript:/i,
    /file:/i,
    /about:/i
  ];
  
  /**
   * 验证 URL 是否安全
   * @param url 待验证的 URL
   * @returns 是否为安全 URL
   */
  static isValidUrl(url: string): boolean {
    if (!url || typeof url !== 'string') {
      return false;
    }
    
    // 检查危险模式
    for (const pattern of this.DANGEROUS_PATTERNS) {
      if (pattern.test(url)) {
        return false;
      }
    }
    
    try {
      const urlObj = new URL(url);
      return this.ALLOWED_PROTOCOLS.includes(urlObj.protocol);
    } catch {
      // 相对 URL 或格式错误的 URL
      return url.startsWith('/') || url.startsWith('./') || url.startsWith('../');
    }
  }
  
  /**
   * 清理 URL
   * @param url 原始 URL
   * @returns 清理后的安全 URL
   */
  static sanitizeUrl(url: string): string {
    if (!this.isValidUrl(url)) {
      return '#';
    }
    
    return url;
  }
}

// 在链接组件中使用
// components/link/index.vue
<template>
  <view 
    class="u-link"
    :class="linkClass"
    @tap="handleClick"
  >
    <slot></slot>
  </view>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { URLValidator } from '../../utils/url-validator';

interface Props {
  href?: string;
  target?: '_blank' | '_self';
  disabled?: boolean;
}

const props = withDefaults(defineProps<Props>(), {
  href: '',
  target: '_self',
  disabled: false
});

const emit = defineEmits<{
  click: [event: Event];
}>;

const safeHref = computed(() => {
  return URLValidator.sanitizeUrl(props.href);
});

const linkClass = computed(() => {
  return {
    'u-link--disabled': props.disabled
  };
});

const handleClick = (event: Event) => {
  if (props.disabled) {
    event.preventDefault();
    return;
  }
  
  if (props.href && URLValidator.isValidUrl(props.href)) {
    // #ifdef H5
    if (props.target === '_blank') {
      window.open(safeHref.value, '_blank');
    } else {
      window.location.href = safeHref.value;
    }
    // #endif
    
    // #ifdef MP
    // 小程序中处理链接跳转
    // #endif
  }
  
  emit('click', event);
};
</script>
```

### 1.2 输入验证

#### 1.2.1 表单验证器

```typescript
// utils/validators.ts

/**
 * 输入验证器
 */
export class InputValidator {
  /**
   * 验证邮箱格式
   * @param email 邮箱地址
   * @returns 验证结果
   */
  static validateEmail(email: string): { valid: boolean; message?: string } {
    if (!email) {
      return { valid: false, message: '邮箱地址不能为空' };
    }
    
    const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
    if (!emailRegex.test(email)) {
      return { valid: false, message: '邮箱格式不正确' };
    }
    
    // 检查邮箱长度
    if (email.length > 254) {
      return { valid: false, message: '邮箱地址过长' };
    }
    
    return { valid: true };
  }
  
  /**
   * 验证手机号格式
   * @param phone 手机号
   * @returns 验证结果
   */
  static validatePhone(phone: string): { valid: boolean; message?: string } {
    if (!phone) {
      return { valid: false, message: '手机号不能为空' };
    }
    
    // 中国大陆手机号验证
    const phoneRegex = /^1[3-9]\d{9}$/;
    if (!phoneRegex.test(phone)) {
      return { valid: false, message: '手机号格式不正确' };
    }
    
    return { valid: true };
  }
  
  /**
   * 验证密码强度
   * @param password 密码
   * @returns 验证结果
   */
  static validatePassword(password: string): { 
    valid: boolean; 
    strength: 'weak' | 'medium' | 'strong';
    message?: string;
  } {
    if (!password) {
      return { valid: false, strength: 'weak', message: '密码不能为空' };
    }
    
    if (password.length < 8) {
      return { valid: false, strength: 'weak', message: '密码长度至少8位' };
    }
    
    if (password.length > 128) {
      return { valid: false, strength: 'weak', message: '密码长度不能超过128位' };
    }
    
    let strength: 'weak' | 'medium' | 'strong' = 'weak';
    let score = 0;
    
    // 包含小写字母
    if (/[a-z]/.test(password)) score++;
    // 包含大写字母
    if (/[A-Z]/.test(password)) score++;
    // 包含数字
    if (/\d/.test(password)) score++;
    // 包含特殊字符
    if (/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password)) score++;
    
    if (score >= 3) {
      strength = 'strong';
    } else if (score >= 2) {
      strength = 'medium';
    }
    
    return { valid: true, strength };
  }
  
  /**
   * 验证身份证号
   * @param idCard 身份证号
   * @returns 验证结果
   */
  static validateIdCard(idCard: string): { valid: boolean; message?: string } {
    if (!idCard) {
      return { valid: false, message: '身份证号不能为空' };
    }
    
    // 18位身份证号验证
    const idCardRegex = /^[1-9]\d{5}(18|19|20)\d{2}((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/;
    if (!idCardRegex.test(idCard)) {
      return { valid: false, message: '身份证号格式不正确' };
    }
    
    // 校验码验证
    const weights = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2];
    const checkCodes = ['1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2'];
    
    let sum = 0;
    for (let i = 0; i < 17; i++) {
      sum += parseInt(idCard[i]) * weights[i];
    }
    
    const checkCode = checkCodes[sum % 11];
    if (checkCode !== idCard[17].toUpperCase()) {
      return { valid: false, message: '身份证号校验失败' };
    }
    
    return { valid: true };
  }
  
  /**
   * 通用文本验证
   * @param text 文本内容
   * @param options 验证选项
   * @returns 验证结果
   */
  static validateText(
    text: string,
    options: {
      minLength?: number;
      maxLength?: number;
      pattern?: RegExp;
      allowEmpty?: boolean;
      sanitize?: boolean;
    } = {}
  ): { valid: boolean; sanitizedText?: string; message?: string } {
    const {
      minLength = 0,
      maxLength = Infinity,
      pattern,
      allowEmpty = true,
      sanitize = true
    } = options;
    
    if (!text && !allowEmpty) {
      return { valid: false, message: '内容不能为空' };
    }
    
    if (!text && allowEmpty) {
      return { valid: true, sanitizedText: '' };
    }
    
    if (text.length < minLength) {
      return { valid: false, message: `内容长度不能少于${minLength}个字符` };
    }
    
    if (text.length > maxLength) {
      return { valid: false, message: `内容长度不能超过${maxLength}个字符` };
    }
    
    if (pattern && !pattern.test(text)) {
      return { valid: false, message: '内容格式不正确' };
    }
    
    const sanitizedText = sanitize ? HTMLSanitizer.escapeHtml(text) : text;
    
    return { valid: true, sanitizedText };
  }
}
```

---

## 2. 数据安全

### 2.1 敏感数据处理

#### 2.1.1 数据脱敏

```typescript
// utils/data-masking.ts

/**
 * 数据脱敏工具
 */
export class DataMasking {
  /**
   * 手机号脱敏
   * @param phone 手机号
   * @returns 脱敏后的手机号
   */
  static maskPhone(phone: string): string {
    if (!phone || phone.length < 11) {
      return phone;
    }
    
    return phone.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2');
  }
  
  /**
   * 邮箱脱敏
   * @param email 邮箱地址
   * @returns 脱敏后的邮箱
   */
  static maskEmail(email: string): string {
    if (!email || !email.includes('@')) {
      return email;
    }
    
    const [username, domain] = email.split('@');
    if (username.length <= 2) {
      return email;
    }
    
    const maskedUsername = username[0] + '*'.repeat(username.length - 2) + username[username.length - 1];
    return `${maskedUsername}@${domain}`;
  }
  
  /**
   * 身份证号脱敏
   * @param idCard 身份证号
   * @returns 脱敏后的身份证号
   */
  static maskIdCard(idCard: string): string {
    if (!idCard || idCard.length < 18) {
      return idCard;
    }
    
    return idCard.replace(/(\d{6})\d{8}(\d{4})/, '$1********$2');
  }
  
  /**
   * 银行卡号脱敏
   * @param cardNumber 银行卡号
   * @returns 脱敏后的银行卡号
   */
  static maskBankCard(cardNumber: string): string {
    if (!cardNumber || cardNumber.length < 8) {
      return cardNumber;
    }
    
    const firstFour = cardNumber.slice(0, 4);
    const lastFour = cardNumber.slice(-4);
    const middleLength = cardNumber.length - 8;
    
    return `${firstFour}${'*'.repeat(middleLength)}${lastFour}`;
  }
  
  /**
   * 姓名脱敏
   * @param name 姓名
   * @returns 脱敏后的姓名
   */
  static maskName(name: string): string {
    if (!name || name.length <= 1) {
      return name;
    }
    
    if (name.length === 2) {
      return name[0] + '*';
    }
    
    return name[0] + '*'.repeat(name.length - 2) + name[name.length - 1];
  }
}

// 在组件中使用
// components/user-info/index.vue
<template>
  <view class="u-user-info">
    <view class="u-user-info__item">
      <text class="u-user-info__label">手机号：</text>
      <text class="u-user-info__value">{{ maskedPhone }}</text>
    </view>
    <view class="u-user-info__item">
      <text class="u-user-info__label">邮箱：</text>
      <text class="u-user-info__value">{{ maskedEmail }}</text>
    </view>
    <view class="u-user-info__item">
      <text class="u-user-info__label">身份证：</text>
      <text class="u-user-info__value">{{ maskedIdCard }}</text>
    </view>
  </view>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { DataMasking } from '../../utils/data-masking';

interface Props {
  phone?: string;
  email?: string;
  idCard?: string;
  showOriginal?: boolean;
}

const props = withDefaults(defineProps<Props>(), {
  phone: '',
  email: '',
  idCard: '',
  showOriginal: false
});

const maskedPhone = computed(() => {
  return props.showOriginal ? props.phone : DataMasking.maskPhone(props.phone);
});

const maskedEmail = computed(() => {
  return props.showOriginal ? props.email : DataMasking.maskEmail(props.email);
});

const maskedIdCard = computed(() => {
  return props.showOriginal ? props.idCard : DataMasking.maskIdCard(props.idCard);
});
</script>
```

### 2.2 本地存储安全

#### 2.2.1 安全存储工具

```typescript
// utils/secure-storage.ts

/**
 * 安全存储工具
 */
export class SecureStorage {
  private static readonly ENCRYPTION_KEY = 'u-kit-secure-key';
  
  /**
   * 简单加密
   * @param data 原始数据
   * @returns 加密后的数据
   */
  private static encrypt(data: string): string {
    // 注意：这是一个简单的示例，生产环境应使用更强的加密算法
    const key = this.ENCRYPTION_KEY;
    let encrypted = '';
    
    for (let i = 0; i < data.length; i++) {
      const keyChar = key[i % key.length];
      const encryptedChar = String.fromCharCode(
        data.charCodeAt(i) ^ keyChar.charCodeAt(0)
      );
      encrypted += encryptedChar;
    }
    
    return btoa(encrypted);
  }
  
  /**
   * 简单解密
   * @param encryptedData 加密的数据
   * @returns 解密后的数据
   */
  private static decrypt(encryptedData: string): string {
    try {
      const encrypted = atob(encryptedData);
      const key = this.ENCRYPTION_KEY;
      let decrypted = '';
      
      for (let i = 0; i < encrypted.length; i++) {
        const keyChar = key[i % key.length];
        const decryptedChar = String.fromCharCode(
          encrypted.charCodeAt(i) ^ keyChar.charCodeAt(0)
        );
        decrypted += decryptedChar;
      }
      
      return decrypted;
    } catch {
      return '';
    }
  }
  
  /**
   * 安全设置存储
   * @param key 存储键
   * @param value 存储值
   * @param encrypt 是否加密
   */
  static setItem(key: string, value: any, encrypt: boolean = false): void {
    try {
      const stringValue = JSON.stringify(value);
      const finalValue = encrypt ? this.encrypt(stringValue) : stringValue;
      
      // #ifdef H5
      localStorage.setItem(key, finalValue);
      // #endif
      
      // #ifdef MP || APP-PLUS
      uni.setStorageSync(key, finalValue);
      // #endif
    } catch (error) {
      console.error('SecureStorage.setItem error:', error);
    }
  }
  
  /**
   * 安全获取存储
   * @param key 存储键
   * @param decrypt 是否解密
   * @returns 存储值
   */
  static getItem<T = any>(key: string, decrypt: boolean = false): T | null {
    try {
      let value: string;
      
      // #ifdef H5
      value = localStorage.getItem(key) || '';
      // #endif
      
      // #ifdef MP || APP-PLUS
      value = uni.getStorageSync(key) || '';
      // #endif
      
      if (!value) {
        return null;
      }
      
      const finalValue = decrypt ? this.decrypt(value) : value;
      return JSON.parse(finalValue);
    } catch (error) {
      console.error('SecureStorage.getItem error:', error);
      return null;
    }
  }
  
  /**
   * 移除存储
   * @param key 存储键
   */
  static removeItem(key: string): void {
    try {
      // #ifdef H5
      localStorage.removeItem(key);
      // #endif
      
      // #ifdef MP || APP-PLUS
      uni.removeStorageSync(key);
      // #endif
    } catch (error) {
      console.error('SecureStorage.removeItem error:', error);
    }
  }
  
  /**
   * 清空所有存储
   */
  static clear(): void {
    try {
      // #ifdef H5
      localStorage.clear();
      // #endif
      
      // #ifdef MP || APP-PLUS
      uni.clearStorageSync();
      // #endif
    } catch (error) {
      console.error('SecureStorage.clear error:', error);
    }
  }
  
  /**
   * 设置敏感数据（自动加密）
   * @param key 存储键
   * @param value 敏感数据
   */
  static setSensitiveData(key: string, value: any): void {
    this.setItem(`sensitive_${key}`, value, true);
  }
  
  /**
   * 获取敏感数据（自动解密）
   * @param key 存储键
   * @returns 敏感数据
   */
  static getSensitiveData<T = any>(key: string): T | null {
    return this.getItem<T>(`sensitive_${key}`, true);
  }
  
  /**
   * 移除敏感数据
   * @param key 存储键
   */
  static removeSensitiveData(key: string): void {
    this.removeItem(`sensitive_${key}`);
  }
}
```

---

## 3. 网络安全

### 3.1 HTTP 请求安全

#### 3.1.1 请求拦截器

```typescript
// utils/http-security.ts

/**
 * HTTP 安全工具
 */
export class HTTPSecurity {
  private static readonly TIMEOUT = 30000; // 30秒超时
  private static readonly MAX_RETRY = 3; // 最大重试次数
  
  /**
   * 安全的 HTTP 请求
   * @param options 请求选项
   * @returns Promise<any>
   */
  static async request(options: {
    url: string;
    method?: 'GET' | 'POST' | 'PUT' | 'DELETE';
    data?: any;
    headers?: Record<string, string>;
    timeout?: number;
    retry?: number;
  }): Promise<any> {
    const {
      url,
      method = 'GET',
      data,
      headers = {},
      timeout = this.TIMEOUT,
      retry = this.MAX_RETRY
    } = options;
    
    // 验证 URL
    if (!this.isValidUrl(url)) {
      throw new Error('Invalid URL');
    }
    
    // 添加安全头
    const secureHeaders = {
      ...headers,
      'X-Requested-With': 'XMLHttpRequest',
      'Content-Type': 'application/json'
    };
    
    // 添加 CSRF Token（如果存在）
    const csrfToken = this.getCSRFToken();
    if (csrfToken) {
      secureHeaders['X-CSRF-Token'] = csrfToken;
    }
    
    let lastError: Error;
    
    for (let i = 0; i <= retry; i++) {
      try {
        const response = await this.makeRequest({
          url,
          method,
          data: this.sanitizeRequestData(data),
          headers: secureHeaders,
          timeout
        });
        
        return this.validateResponse(response);
      } catch (error) {
        lastError = error as Error;
        
        // 如果是最后一次重试，抛出错误
        if (i === retry) {
          throw lastError;
        }
        
        // 等待后重试
        await this.delay(Math.pow(2, i) * 1000);
      }
    }
    
    throw lastError!;
  }
  
  /**
   * 验证 URL 是否安全
   * @param url URL 地址
   * @returns 是否安全
   */
  private static isValidUrl(url: string): boolean {
    try {
      const urlObj = new URL(url);
      
      // 只允许 HTTPS 和 HTTP 协议
      if (!['https:', 'http:'].includes(urlObj.protocol)) {
        return false;
      }
      
      // 检查是否为内网地址（生产环境应禁止）
      if (process.env.NODE_ENV === 'production') {
        const hostname = urlObj.hostname;
        const privateRanges = [
          /^127\./,
          /^10\./,
          /^172\.(1[6-9]|2[0-9]|3[0-1])\./,
          /^192\.168\./,
          /^localhost$/i
        ];
        
        if (privateRanges.some(range => range.test(hostname))) {
          return false;
        }
      }
      
      return true;
    } catch {
      return false;
    }
  }
  
  /**
   * 清理请求数据
   * @param data 原始数据
   * @returns 清理后的数据
   */
  private static sanitizeRequestData(data: any): any {
    if (!data) return data;
    
    if (typeof data === 'string') {
      return HTMLSanitizer.escapeHtml(data);
    }
    
    if (Array.isArray(data)) {
      return data.map(item => this.sanitizeRequestData(item));
    }
    
    if (typeof data === 'object') {
      const sanitized: any = {};
      for (const [key, value] of Object.entries(data)) {
        sanitized[key] = this.sanitizeRequestData(value);
      }
      return sanitized;
    }
    
    return data;
  }
  
  /**
   * 发起实际请求
   * @param options 请求选项
   * @returns Promise<any>
   */
  private static makeRequest(options: {
    url: string;
    method: string;
    data?: any;
    headers: Record<string, string>;
    timeout: number;
  }): Promise<any> {
    return new Promise((resolve, reject) => {
      // #ifdef H5
      const xhr = new XMLHttpRequest();
      xhr.timeout = options.timeout;
      
      xhr.onload = () => {
        if (xhr.status >= 200 && xhr.status < 300) {
          try {
            const response = JSON.parse(xhr.responseText);
            resolve(response);
          } catch {
            resolve(xhr.responseText);
          }
        } else {
          reject(new Error(`HTTP ${xhr.status}: ${xhr.statusText}`));
        }
      };
      
      xhr.onerror = () => reject(new Error('Network error'));
      xhr.ontimeout = () => reject(new Error('Request timeout'));
      
      xhr.open(options.method, options.url);
      
      Object.entries(options.headers).forEach(([key, value]) => {
        xhr.setRequestHeader(key, value);
      });
      
      xhr.send(options.data ? JSON.stringify(options.data) : null);
      // #endif
      
      // #ifdef MP || APP-PLUS
      uni.request({
        url: options.url,
        method: options.method as any,
        data: options.data,
        header: options.headers,
        timeout: options.timeout,
        success: (res) => {
          if (res.statusCode >= 200 && res.statusCode < 300) {
            resolve(res.data);
          } else {
            reject(new Error(`HTTP ${res.statusCode}`));
          }
        },
        fail: (error) => {
          reject(new Error(error.errMsg || 'Request failed'));
        }
      });
      // #endif
    });
  }
  
  /**
   * 验证响应数据
   * @param response 响应数据
   * @returns 验证后的响应数据
   */
  private static validateResponse(response: any): any {
    // 检查响应是否包含恶意内容
    if (typeof response === 'string') {
      // 检查是否包含脚本标签
      if (/<script[^>]*>[\s\S]*?<\/script>/i.test(response)) {
        throw new Error('Response contains potentially malicious content');
      }
    }
    
    return response;
  }
  
  /**
   * 获取 CSRF Token
   * @returns CSRF Token
   */
  private static getCSRFToken(): string | null {
    // #ifdef H5
    const metaTag = document.querySelector('meta[name="csrf-token"]');
    return metaTag ? metaTag.getAttribute('content') : null;
    // #endif
    
    // #ifdef MP || APP-PLUS
    return SecureStorage.getItem('csrf_token');
    // #endif
  }
  
  /**
   * 延迟函数
   * @param ms 延迟毫秒数
   * @returns Promise<void>
   */
  private static delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

### 3.2 API 密钥管理

#### 3.2.1 密钥管理器

```typescript
// utils/api-key-manager.ts

/**
 * API 密钥管理器
 */
export class APIKeyManager {
  private static keys: Map<string, string> = new Map();
  private static readonly KEY_PREFIX = 'api_key_';
  
  /**
   * 设置 API 密钥
   * @param service 服务名称
   * @param key API 密钥
   */
  static setAPIKey(service: string, key: string): void {
    if (!service || !key) {
      throw new Error('Service name and API key are required');
    }
    
    // 验证密钥格式
    if (!this.validateKeyFormat(key)) {
      throw new Error('Invalid API key format');
    }
    
    // 加密存储
    SecureStorage.setSensitiveData(`${this.KEY_PREFIX}${service}`, key);
    this.keys.set(service, key);
  }
  
  /**
   * 获取 API 密钥
   * @param service 服务名称
   * @returns API 密钥
   */
  static getAPIKey(service: string): string | null {
    if (!service) {
      return null;
    }
    
    // 先从内存中获取
    if (this.keys.has(service)) {
      return this.keys.get(service)!;
    }
    
    // 从安全存储中获取
    const key = SecureStorage.getSensitiveData<string>(`${this.KEY_PREFIX}${service}`);
    if (key) {
      this.keys.set(service, key);
      return key;
    }
    
    return null;
  }
  
  /**
   * 移除 API 密钥
   * @param service 服务名称
   */
  static removeAPIKey(service: string): void {
    if (!service) {
      return;
    }
    
    this.keys.delete(service);
    SecureStorage.removeSensitiveData(`${this.KEY_PREFIX}${service}`);
  }
  
  /**
   * 清空所有 API 密钥
   */
  static clearAllKeys(): void {
    this.keys.clear();
    
    // 清理存储中的密钥
    const services = this.getAllServices();
    services.forEach(service => {
      SecureStorage.removeSensitiveData(`${this.KEY_PREFIX}${service}`);
    });
  }
  
  /**
   * 验证密钥格式
   * @param key API 密钥
   * @returns 是否有效
   */
  private static validateKeyFormat(key: string): boolean {
    // 基本长度检查
    if (key.length < 16 || key.length > 256) {
      return false;
    }
    
    // 检查是否包含危险字符
    const dangerousChars = /[<>"'&]/;
    if (dangerousChars.test(key)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * 获取所有服务名称
   * @returns 服务名称列表
   */
  private static getAllServices(): string[] {
    // 这里应该从实际存储中获取所有服务名称
    // 简化实现，返回内存中的服务名称
    return Array.from(this.keys.keys());
  }
  
  /**
   * 生成安全的请求头
   * @param service 服务名称
   * @param additionalHeaders 额外的请求头
   * @returns 安全的请求头
   */
  static generateSecureHeaders(
    service: string,
    additionalHeaders: Record<string, string> = {}
  ): Record<string, string> {
    const apiKey = this.getAPIKey(service);
    if (!apiKey) {
      throw new Error(`API key not found for service: ${service}`);
    }
    
    return {
      ...additionalHeaders,
      'Authorization': `Bearer ${apiKey}`,
      'X-API-Key': apiKey,
      'User-Agent': 'u-kit/1.0.0',
      'Accept': 'application/json',
      'Content-Type': 'application/json'
    };
  }
}
```

---

## 4. 权限控制

### 4.1 组件权限控制

#### 4.1.1 权限指令

```typescript
// directives/permission.ts

import type { Directive, DirectiveBinding } from 'vue';

/**
 * 权限管理器
 */
class PermissionManager {
  private static permissions: Set<string> = new Set();
  private static roles: Set<string> = new Set();
  
  /**
   * 设置用户权限
   * @param permissions 权限列表
   */
  static setPermissions(permissions: string[]): void {
    this.permissions.clear();
    permissions.forEach(permission => {
      this.permissions.add(permission);
    });
  }
  
  /**
   * 设置用户角色
   * @param roles 角色列表
   */
  static setRoles(roles: string[]): void {
    this.roles.clear();
    roles.forEach(role => {
      this.roles.add(role);
    });
  }
  
  /**
   * 检查是否有权限
   * @param permission 权限名称
   * @returns 是否有权限
   */
  static hasPermission(permission: string): boolean {
    return this.permissions.has(permission);
  }
  
  /**
   * 检查是否有角色
   * @param role 角色名称
   * @returns 是否有角色
   */
  static hasRole(role: string): boolean {
    return this.roles.has(role);
  }
  
  /**
   * 检查是否有任一权限
   * @param permissions 权限列表
   * @returns 是否有任一权限
   */
  static hasAnyPermission(permissions: string[]): boolean {
    return permissions.some(permission => this.hasPermission(permission));
  }
  
  /**
   * 检查是否有所有权限
   * @param permissions 权限列表
   * @returns 是否有所有权限
   */
  static hasAllPermissions(permissions: string[]): boolean {
    return permissions.every(permission => this.hasPermission(permission));
  }
  
  /**
   * 清空权限和角色
   */
  static clear(): void {
    this.permissions.clear();
    this.roles.clear();
  }
}

/**
 * 权限指令
 */
export const vPermission: Directive = {
  mounted(el: HTMLElement, binding: DirectiveBinding) {
    checkPermission(el, binding);
  },
  
  updated(el: HTMLElement, binding: DirectiveBinding) {
    checkPermission(el, binding);
  }
};

/**
 * 检查权限
 * @param el DOM 元素
 * @param binding 指令绑定
 */
function checkPermission(el: HTMLElement, binding: DirectiveBinding) {
  const { value, modifiers } = binding;
  
  if (!value) {
    console.warn('v-permission directive requires a value');
    return;
  }
  
  let hasPermission = false;
  
  if (typeof value === 'string') {
    // 单个权限
    hasPermission = PermissionManager.hasPermission(value);
  } else if (Array.isArray(value)) {
    // 多个权限
    if (modifiers.all) {
      // 需要所有权限
      hasPermission = PermissionManager.hasAllPermissions(value);
    } else {
      // 需要任一权限
      hasPermission = PermissionManager.hasAnyPermission(value);
    }
  } else if (typeof value === 'object') {
    // 权限和角色混合检查
    const { permissions = [], roles = [] } = value;
    
    const hasRequiredPermissions = permissions.length === 0 || 
      (modifiers.all 
        ? PermissionManager.hasAllPermissions(permissions)
        : PermissionManager.hasAnyPermission(permissions));
    
    const hasRequiredRoles = roles.length === 0 ||
      roles.some((role: string) => PermissionManager.hasRole(role));
    
    hasPermission = hasRequiredPermissions && hasRequiredRoles;
  }
  
  if (!hasPermission) {
    if (modifiers.hide) {
      // 隐藏元素
      el.style.display = 'none';
    } else if (modifiers.disable) {
      // 禁用元素
      el.setAttribute('disabled', 'true');
      el.style.opacity = '0.5';
      el.style.pointerEvents = 'none';
    } else {
      // 默认移除元素
      el.parentNode?.removeChild(el);
    }
  } else {
    // 恢复元素状态
    if (modifiers.hide) {
      el.style.display = '';
    } else if (modifiers.disable) {
      el.removeAttribute('disabled');
      el.style.opacity = '';
      el.style.pointerEvents = '';
    }
  }
}

export { PermissionManager };
```

#### 4.1.2 权限组件

```vue
<!-- components/permission/index.vue -->
<template>
  <view v-if="hasPermission" class="u-permission">
    <slot></slot>
  </view>
  <view v-else-if="showFallback" class="u-permission-fallback">
    <slot name="fallback">
      <view class="u-permission-fallback__default">
        <u-icon name="lock" size="48" color="#ccc" />
        <text class="u-permission-fallback__text">{{ fallbackText }}</text>
      </view>
    </slot>
  </view>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { PermissionManager } from '../../directives/permission';

interface Props {
  permission?: string | string[];
  role?: string | string[];
  requireAll?: boolean;
  showFallback?: boolean;
  fallbackText?: string;
}

const props = withDefaults(defineProps<Props>(), {
  permission: '',
  role: '',
  requireAll: false,
  showFallback: false,
  fallbackText: '暂无权限访问'
});

const hasPermission = computed(() => {
  // 检查权限
  let hasRequiredPermissions = true;
  if (props.permission) {
    const permissions = Array.isArray(props.permission) 
      ? props.permission 
      : [props.permission];
    
    hasRequiredPermissions = props.requireAll
      ? PermissionManager.hasAllPermissions(permissions)
      : PermissionManager.hasAnyPermission(permissions);
  }
  
  // 检查角色
  let hasRequiredRoles = true;
  if (props.role) {
    const roles = Array.isArray(props.role) ? props.role : [props.role];
    hasRequiredRoles = roles.some(role => PermissionManager.hasRole(role));
  }
  
  return hasRequiredPermissions && hasRequiredRoles;
});
</script>

<style lang="scss">
.u-permission-fallback {
  &__default {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 40px 20px;
    color: #999;
  }
  
  &__text {
    margin-top: 12px;
    font-size: 14px;
    color: #999;
  }
}
</style>
```

---

## 5. 安全配置

### 5.1 内容安全策略 (CSP)

#### 5.1.1 CSP 配置

```html
<!-- index.html -->
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- 内容安全策略 -->
  <meta http-equiv="Content-Security-Policy" content="
    default-src 'self';
    script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.jsdelivr.net;
    style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
    img-src 'self' data: https: blob:;
    font-src 'self' https://fonts.gstatic.com;
    connect-src 'self' https://api.example.com wss://ws.example.com;
    media-src 'self' https:;
    object-src 'none';
    base-uri 'self';
    form-action 'self';
    frame-ancestors 'none';
    upgrade-insecure-requests;
  ">
  
  <!-- CSRF 保护 -->
  <meta name="csrf-token" content="{{ csrf_token }}">
  
  <!-- 防止 MIME 类型嗅探 -->
  <meta http-equiv="X-Content-Type-Options" content="nosniff">
  
  <!-- 防止点击劫持 -->
  <meta http-equiv="X-Frame-Options" content="DENY">
  
  <!-- XSS 保护 -->
  <meta http-equiv="X-XSS-Protection" content="1; mode=block">
  
  <!-- 引用策略 -->
  <meta name="referrer" content="strict-origin-when-cross-origin">
  
  <title>u-kit Demo</title>
</head>
<body>
  <div id="app"></div>
</body>
</html>
```

### 5.2 环境变量管理

#### 5.2.1 环境配置

```typescript
// config/security.ts

/**
 * 安全配置
 */
export interface SecurityConfig {
  // 是否启用 HTTPS
  enforceHTTPS: boolean;
  
  // 是否启用 CSP
  enableCSP: boolean;
  
  // 允许的域名
  allowedDomains: string[];
  
  // API 基础 URL
  apiBaseURL: string;
  
  // 是否启用请求加密
  enableRequestEncryption: boolean;
  
  // 是否启用响应验证
  enableResponseValidation: boolean;
  
  // 会话超时时间（毫秒）
  sessionTimeout: number;
  
  // 最大文件上传大小（字节）
  maxFileSize: number;
  
  // 允许的文件类型
  allowedFileTypes: string[];
}

/**
 * 获取安全配置
 * @returns 安全配置
 */
export function getSecurityConfig(): SecurityConfig {
  const env = process.env.NODE_ENV || 'development';
  
  const baseConfig: SecurityConfig = {
    enforceHTTPS: env === 'production',
    enableCSP: env === 'production',
    allowedDomains: ['localhost', '127.0.0.1'],
    apiBaseURL: 'http://localhost:3000/api',
    enableRequestEncryption: false,
    enableResponseValidation: true,
    sessionTimeout: 30 * 60 * 1000, // 30分钟
    maxFileSize: 10 * 1024 * 1024, // 10MB
    allowedFileTypes: [
      'image/jpeg',
      'image/png',
      'image/gif',
      'image/webp',
      'application/pdf',
      'text/plain'
    ]
  };
  
  if (env === 'production') {
    return {
      ...baseConfig,
      allowedDomains: ['yourdomain.com', 'api.yourdomain.com'],
      apiBaseURL: 'https://api.yourdomain.com',
      enableRequestEncryption: true,
      sessionTimeout: 15 * 60 * 1000 // 15分钟
    };
  }
  
  if (env === 'staging') {
    return {
      ...baseConfig,
      allowedDomains: ['staging.yourdomain.com'],
      apiBaseURL: 'https://staging-api.yourdomain.com',
      enableRequestEncryption: true
    };
  }
  
  return baseConfig;
}

/**
 * 验证环境配置
 */
export function validateSecurityConfig(): void {
  const config = getSecurityConfig();
  
  // 生产环境必须启用 HTTPS
  if (process.env.NODE_ENV === 'production' && !config.enforceHTTPS) {
    throw new Error('HTTPS must be enabled in production environment');
  }
  
  // 验证 API URL
  if (!config.apiBaseURL) {
    throw new Error('API base URL is required');
  }
  
  // 验证允许的域名
  if (!config.allowedDomains.length) {
    throw new Error('At least one allowed domain is required');
  }
  
  console.log('Security configuration validated successfully');
}
```

---

## 6. 安全测试

### 6.1 安全测试用例

#### 6.1.1 XSS 测试

```typescript
// __tests__/security/xss.test.ts

import { mount } from '@vue/test-utils';
import { describe, it, expect } from 'vitest';
import { HTMLSanitizer } from '../../utils/security';
import URichText from '../../components/rich-text/index.vue';

describe('XSS Protection', () => {
  describe('HTMLSanitizer', () => {
    it('should remove script tags', () => {
      const maliciousHtml = '<p>Hello</p><script>alert("XSS")</script>';
      const sanitized = HTMLSanitizer.sanitize(maliciousHtml);
      
      expect(sanitized).not.toContain('<script>');
      expect(sanitized).not.toContain('alert');
      expect(sanitized).toContain('<p>Hello</p>');
    });
    
    it('should remove event handlers', () => {
      const maliciousHtml = '<div onclick="alert(\"XSS\")">Click me</div>';
      const sanitized = HTMLSanitizer.sanitize(maliciousHtml);
      
      expect(sanitized).not.toContain('onclick');
      expect(sanitized).not.toContain('alert');
    });
    
    it('should remove dangerous protocols', () => {
      const maliciousHtml = '<a href="javascript:alert(\"XSS\")">Link</a>';
      const sanitized = HTMLSanitizer.sanitize(maliciousHtml);
      
      expect(sanitized).not.toContain('javascript:');
    });
    
    it('should escape HTML characters', () => {
      const text = '<script>alert("XSS")</script>';
      const escaped = HTMLSanitizer.escapeHtml(text);
      
      expect(escaped).toBe('&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;');
    });
  });
  
  describe('URichText Component', () => {
    it('should sanitize content by default', () => {
      const maliciousContent = '<p>Safe content</p><script>alert("XSS")</script>';
      const wrapper = mount(URichText, {
        props: {
          content: maliciousContent
        }
      });
      
      const html = wrapper.html();
      expect(html).not.toContain('<script>');
      expect(html).toContain('<p>Safe content</p>');
    });
    
    it('should allow unsafe content when explicitly enabled', () => {
      const maliciousContent = '<p>Content</p><script>alert("XSS")</script>';
      const wrapper = mount(URichText, {
        props: {
          content: maliciousContent,
          allowUnsafe: true
        }
      });
      
      const html = wrapper.html();
      expect(html).toContain('<script>');
    });
  });
});
```

#### 6.1.2 输入验证测试

```typescript
// __tests__/security/input-validation.test.ts

import { describe, it, expect } from 'vitest';
import { InputValidator } from '../../utils/validators';

describe('Input Validation', () => {
  describe('Email Validation', () => {
    it('should validate correct email addresses', () => {
      const validEmails = [
        'test@example.com',
        'user.name@domain.co.uk',
        'user+tag@example.org'
      ];
      
      validEmails.forEach(email => {
        const result = InputValidator.validateEmail(email);
        expect(result.valid).toBe(true);
      });
    });
    
    it('should reject invalid email addresses', () => {
      const invalidEmails = [
        'invalid-email',
        '@example.com',
        'test@',
        'test..test@example.com',
        'test@example',
        'a'.repeat(250) + '@example.com' // 过长的邮箱
      ];
      
      invalidEmails.forEach(email => {
        const result = InputValidator.validateEmail(email);
        expect(result.valid).toBe(false);
        expect(result.message).toBeDefined();
      });
    });
  });
  
  describe('Password Validation', () => {
    it('should validate strong passwords', () => {
      const strongPasswords = [
        'StrongP@ssw0rd',
        'MySecure123!',
        'Complex#Pass1'
      ];
      
      strongPasswords.forEach(password => {
        const result = InputValidator.validatePassword(password);
        expect(result.valid).toBe(true);
        expect(result.strength).toBe('strong');
      });
    });
    
    it('should reject weak passwords', () => {
      const weakPasswords = [
        '123456',
        'password',
        'abc123',
        '12345678',
        'a'.repeat(129) // 过长的密码
      ];
      
      weakPasswords.forEach(password => {
        const result = InputValidator.validatePassword(password);
        expect(result.valid).toBe(false);
        expect(result.message).toBeDefined();
      });
    });
  });
  
  describe('Text Validation', () => {
    it('should sanitize malicious text', () => {
      const maliciousText = '<script>alert("XSS")</script>Hello';
      const result = InputValidator.validateText(maliciousText, {
        sanitize: true
      });
      
      expect(result.valid).toBe(true);
      expect(result.sanitizedText).not.toContain('<script>');
      expect(result.sanitizedText).toContain('Hello');
    });
    
    it('should enforce length limits', () => {
      const longText = 'a'.repeat(1000);
      const result = InputValidator.validateText(longText, {
        maxLength: 100
      });
      
      expect(result.valid).toBe(false);
      expect(result.message).toContain('长度不能超过');
    });
  });
});
```

#### 6.1.3 权限测试

```typescript
// __tests__/security/permission.test.ts

import { mount } from '@vue/test-utils';
import { describe, it, expect, beforeEach } from 'vitest';
import { PermissionManager } from '../../directives/permission';
import UPermission from '../../components/permission/index.vue';

describe('Permission Control', () => {
  beforeEach(() => {
    PermissionManager.clear();
  });
  
  describe('PermissionManager', () => {
    it('should set and check permissions correctly', () => {
      PermissionManager.setPermissions(['read', 'write']);
      
      expect(PermissionManager.hasPermission('read')).toBe(true);
      expect(PermissionManager.hasPermission('write')).toBe(true);
      expect(PermissionManager.hasPermission('delete')).toBe(false);
    });
    
    it('should check multiple permissions', () => {
      PermissionManager.setPermissions(['read', 'write']);
      
      expect(PermissionManager.hasAnyPermission(['read', 'delete'])).toBe(true);
      expect(PermissionManager.hasAllPermissions(['read', 'write'])).toBe(true);
      expect(PermissionManager.hasAllPermissions(['read', 'delete'])).toBe(false);
    });
    
    it('should set and check roles correctly', () => {
      PermissionManager.setRoles(['admin', 'user']);
      
      expect(PermissionManager.hasRole('admin')).toBe(true);
      expect(PermissionManager.hasRole('guest')).toBe(false);
    });
  });
  
  describe('UPermission Component', () => {
    it('should show content when permission is granted', () => {
      PermissionManager.setPermissions(['read']);
      
      const wrapper = mount(UPermission, {
        props: {
          permission: 'read'
        },
        slots: {
          default: '<div>Protected Content</div>'
        }
      });
      
      expect(wrapper.text()).toContain('Protected Content');
    });
    
    it('should hide content when permission is denied', () => {
      PermissionManager.setPermissions(['write']);
      
      const wrapper = mount(UPermission, {
        props: {
          permission: 'read'
        },
        slots: {
          default: '<div>Protected Content</div>'
        }
      });
      
      expect(wrapper.text()).not.toContain('Protected Content');
    });
    
    it('should show fallback when permission is denied and fallback is enabled', () => {
      PermissionManager.setPermissions(['write']);
      
      const wrapper = mount(UPermission, {
        props: {
          permission: 'read',
          showFallback: true,
          fallbackText: 'Access Denied'
        },
        slots: {
          default: '<div>Protected Content</div>'
        }
      });
      
      expect(wrapper.text()).toContain('Access Denied');
      expect(wrapper.text()).not.toContain('Protected Content');
    });
  });
});
```

---

## 7. 安全最佳实践

### 7.1 开发阶段安全检查清单

#### 7.1.1 代码审查清单

- [ ] **输入验证**
  - 所有用户输入都经过验证和清理
  - 使用白名单而非黑名单进行验证
  - 对文件上传进行类型和大小限制
  
- [ ] **输出编码**
  - HTML 内容使用适当的编码
  - URL 参数正确编码
  - JSON 数据安全序列化
  
- [ ] **身份验证和授权**
  - 实现适当的权限控制
  - 使用安全的会话管理
  - 避免硬编码凭据
  
- [ ] **数据保护**
  - 敏感数据加密存储
  - 使用 HTTPS 传输敏感信息
  - 实现适当的数据脱敏
  
- [ ] **错误处理**
  - 不泄露敏感信息的错误消息
  - 实现适当的日志记录
  - 优雅处理异常情况

#### 7.1.2 安全配置检查

```typescript
// utils/security-checker.ts

/**
 * 安全配置检查器
 */
export class SecurityChecker {
  /**
   * 检查安全配置
   * @returns 检查结果
   */
  static checkSecurityConfig(): {
    passed: boolean;
    issues: string[];
    warnings: string[];
  } {
    const issues: string[] = [];
    const warnings: string[] = [];
    
    // 检查 HTTPS
    if (process.env.NODE_ENV === 'production') {
      if (location.protocol !== 'https:') {
        issues.push('生产环境必须使用 HTTPS');
      }
    }
    
    // 检查 CSP
    const cspMeta = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
    if (!cspMeta) {
      warnings.push('未设置内容安全策略 (CSP)');
    }
    
    // 检查 CSRF Token
    const csrfMeta = document.querySelector('meta[name="csrf-token"]');
    if (!csrfMeta) {
      warnings.push('未设置 CSRF Token');
    }
    
    // 检查安全头
    const securityHeaders = [
      'X-Content-Type-Options',
      'X-Frame-Options',
      'X-XSS-Protection'
    ];
    
    securityHeaders.forEach(header => {
      const meta = document.querySelector(`meta[http-equiv="${header}"]`);
      if (!meta) {
        warnings.push(`未设置安全头: ${header}`);
      }
    });
    
    // 检查本地存储
    this.checkLocalStorage(warnings);
    
    // 检查第三方脚本
    this.checkThirdPartyScripts(warnings);
    
    return {
      passed: issues.length === 0,
      issues,
      warnings
    };
  }
  
  /**
   * 检查本地存储安全
   * @param warnings 警告列表
   */
  private static checkLocalStorage(warnings: string[]): void {
    try {
      // 检查是否存储了敏感信息
      const sensitiveKeys = ['password', 'token', 'secret', 'key'];
      
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key) {
          const lowerKey = key.toLowerCase();
          if (sensitiveKeys.some(sensitive => lowerKey.includes(sensitive))) {
            const value = localStorage.getItem(key);
            if (value && !this.isEncrypted(value)) {
              warnings.push(`本地存储中可能包含未加密的敏感信息: ${key}`);
            }
          }
        }
      }
    } catch (error) {
      warnings.push('无法检查本地存储安全性');
    }
  }
  
  /**
   * 检查第三方脚本
   * @param warnings 警告列表
   */
  private static checkThirdPartyScripts(warnings: string[]): void {
    const scripts = document.querySelectorAll('script[src]');
    const trustedDomains = [
      'cdn.jsdelivr.net',
      'unpkg.com',
      'cdnjs.cloudflare.com'
    ];
    
    scripts.forEach(script => {
      const src = script.getAttribute('src');
      if (src) {
        try {
          const url = new URL(src, location.origin);
          if (url.origin !== location.origin) {
            const isTrusted = trustedDomains.some(domain => 
              url.hostname.includes(domain)
            );
            
            if (!isTrusted) {
              warnings.push(`检测到第三方脚本: ${url.hostname}`);
            }
          }
        } catch {
          warnings.push(`无效的脚本 URL: ${src}`);
        }
      }
    });
  }
  
  /**
   * 检查字符串是否已加密
   * @param value 字符串值
   * @returns 是否已加密
   */
  private static isEncrypted(value: string): boolean {
    // 简单的加密检测（实际应用中需要更复杂的逻辑）
    try {
      // 尝试 base64 解码
      atob(value);
      return true;
    } catch {
      return false;
    }
  }
  
  /**
   * 生成安全报告
   * @returns 安全报告
   */
  static generateSecurityReport(): string {
    const result = this.checkSecurityConfig();
    
    let report = '# 安全检查报告\n\n';
    
    if (result.passed) {
      report += '✅ **安全检查通过**\n\n';
    } else {
      report += '❌ **安全检查失败**\n\n';
    }
    
    if (result.issues.length > 0) {
      report += '## 严重问题\n\n';
      result.issues.forEach(issue => {
        report += `- ❌ ${issue}\n`;
      });
      report += '\n';
    }
    
    if (result.warnings.length > 0) {
      report += '## 警告\n\n';
      result.warnings.forEach(warning => {
        report += `- ⚠️ ${warning}\n`;
      });
      report += '\n';
    }
    
    report += `## 检查时间\n\n${new Date().toLocaleString()}\n`;
    
    return report;
  }
}
```

### 7.2 部署安全

#### 7.2.1 构建时安全检查

```javascript
// scripts/security-check.js

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

/**
 * 构建时安全检查
 */
class BuildSecurityChecker {
  constructor() {
    this.issues = [];
    this.warnings = [];
  }
  
  /**
   * 执行安全检查
   */
  async check() {
    console.log('🔍 开始安全检查...');
    
    await this.checkDependencies();
    await this.checkSourceCode();
    await this.checkConfiguration();
    await this.checkAssets();
    
    this.generateReport();
    
    if (this.issues.length > 0) {
      console.error('❌ 安全检查失败');
      process.exit(1);
    } else {
      console.log('✅ 安全检查通过');
    }
  }
  
  /**
   * 检查依赖安全
   */
  async checkDependencies() {
    console.log('📦 检查依赖安全...');
    
    try {
      const packageJson = JSON.parse(
        fs.readFileSync('package.json', 'utf8')
      );
      
      // 检查已知的危险包
      const dangerousPackages = [
        'event-stream',
        'flatmap-stream',
        'eslint-scope'
      ];
      
      const allDeps = {
        ...packageJson.dependencies,
        ...packageJson.devDependencies
      };
      
      dangerousPackages.forEach(pkg => {
        if (allDeps[pkg]) {
          this.issues.push(`检测到危险依赖: ${pkg}`);
        }
      });
      
      // 检查过时的依赖
      const outdatedPackages = [
        'lodash',
        'moment',
        'request'
      ];
      
      outdatedPackages.forEach(pkg => {
        if (allDeps[pkg]) {
          this.warnings.push(`建议更新过时依赖: ${pkg}`);
        }
      });
      
    } catch (error) {
      this.warnings.push('无法读取 package.json');
    }
  }
  
  /**
   * 检查源代码安全
   */
  async checkSourceCode() {
    console.log('📝 检查源代码安全...');
    
    const srcDir = path.join(process.cwd(), 'src');
    if (!fs.existsSync(srcDir)) {
      return;
    }
    
    await this.scanDirectory(srcDir);
  }
  
  /**
   * 扫描目录
   * @param {string} dir 目录路径
   */
  async scanDirectory(dir) {
    const files = fs.readdirSync(dir);
    
    for (const file of files) {
      const filePath = path.join(dir, file);
      const stat = fs.statSync(filePath);
      
      if (stat.isDirectory()) {
        await this.scanDirectory(filePath);
      } else if (this.isSourceFile(filePath)) {
        await this.scanFile(filePath);
      }
    }
  }
  
  /**
   * 检查是否为源代码文件
   * @param {string} filePath 文件路径
   * @returns {boolean}
   */
  isSourceFile(filePath) {
    const ext = path.extname(filePath);
    return ['.js', '.ts', '.vue', '.jsx', '.tsx'].includes(ext);
  }
  
  /**
   * 扫描文件
   * @param {string} filePath 文件路径
   */
  async scanFile(filePath) {
    try {
      const content = fs.readFileSync(filePath, 'utf8');
      
      // 检查硬编码的敏感信息
      const sensitivePatterns = [
        /password\s*[=:]\s*["'][^"']+["']/i,
        /api[_-]?key\s*[=:]\s*["'][^"']+["']/i,
        /secret\s*[=:]\s*["'][^"']+["']/i,
        /token\s*[=:]\s*["'][^"']+["']/i,
        /["'][A-Za-z0-9]{32,}["']/g // 可能的密钥
      ];
      
      sensitivePatterns.forEach(pattern => {
        if (pattern.test(content)) {
          this.issues.push(`${filePath}: 可能包含硬编码的敏感信息`);
        }
      });
      
      // 检查危险的函数调用
      const dangerousFunctions = [
        /eval\s*\(/,
        /innerHTML\s*=/,
        /document\.write\s*\(/,
        /setTimeout\s*\(\s*["']/,
        /setInterval\s*\(\s*["']/
      ];
      
      dangerousFunctions.forEach(pattern => {
        if (pattern.test(content)) {
          this.warnings.push(`${filePath}: 使用了潜在危险的函数`);
        }
      });
      
    } catch (error) {
      this.warnings.push(`无法读取文件: ${filePath}`);
    }
  }
  
  /**
   * 检查配置安全
   */
  async checkConfiguration() {
    console.log('⚙️ 检查配置安全...');
    
    // 检查环境变量文件
    const envFiles = ['.env', '.env.local', '.env.production'];
    
    envFiles.forEach(envFile => {
      if (fs.existsSync(envFile)) {
        const content = fs.readFileSync(envFile, 'utf8');
        
        // 检查是否包含敏感信息
        if (content.includes('password') || content.includes('secret')) {
          this.warnings.push(`${envFile}: 可能包含敏感配置`);
        }
      }
    });
  }
  
  /**
   * 检查资源文件
   */
  async checkAssets() {
    console.log('🖼️ 检查资源文件...');
    
    const publicDir = path.join(process.cwd(), 'public');
    if (!fs.existsSync(publicDir)) {
      return;
    }
    
    // 检查是否有敏感文件
    const sensitiveFiles = [
      '.env',
      'config.json',
      'database.json',
      '.git',
      'node_modules'
    ];
    
    sensitiveFiles.forEach(file => {
      const filePath = path.join(publicDir, file);
      if (fs.existsSync(filePath)) {
        this.issues.push(`公共目录包含敏感文件: ${file}`);
      }
    });
  }
  
  /**
   * 生成报告
   */
  generateReport() {
    console.log('\n📊 安全检查报告:');
    console.log('================');
    
    if (this.issues.length > 0) {
      console.log('\n❌ 严重问题:');
      this.issues.forEach(issue => {
        console.log(`  - ${issue}`);
      });
    }
    
    if (this.warnings.length > 0) {
      console.log('\n⚠️ 警告:');
      this.warnings.forEach(warning => {
        console.log(`  - ${warning}`);
      });
    }
    
    if (this.issues.length === 0 && this.warnings.length === 0) {
      console.log('\n✅ 未发现安全问题');
    }
    
    console.log('\n================\n');
  }
}

// 执行检查
if (require.main === module) {
  const checker = new BuildSecurityChecker();
  checker.check().catch(console.error);
}

module.exports = BuildSecurityChecker;
```

---

## 8. 总结

### 8.1 安全开发要点

1. **输入验证**: 对所有用户输入进行严格验证和清理
2. **输出编码**: 正确编码输出内容，防止 XSS 攻击
3. **权限控制**: 实现细粒度的权限管理系统
4. **数据保护**: 加密存储敏感数据，使用安全传输
5. **安全配置**: 正确配置 CSP、HTTPS 等安全策略
6. **依赖管理**: 定期更新依赖，避免使用有安全漏洞的包
7. **错误处理**: 不泄露敏感信息的错误处理
8. **安全测试**: 编写全面的安全测试用例

### 8.2 持续安全改进

- 定期进行安全审计
- 关注安全漏洞公告
- 更新安全最佳实践
- 培训开发团队安全意识
- 建立安全事件响应流程

通过遵循本文档的安全规范和最佳实践，可以确保 u-kit 组件库的安全性，保护用户数据和应用程序免受常见的安全威胁。
