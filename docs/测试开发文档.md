# kit-ui 测试开发文档

## 概述

本文档详细阐述了 kit-ui 组件库的测试策略、测试工具配置、测试最佳实践和测试流程，确保组件库的质量和稳定性。

---

## 1. 测试策略

### 1.1 测试金字塔

```base
        E2E 测试 (10%)
      ┌─────────────────┐
     │   端到端测试     │
    └─────────────────┘
   ┌─────────────────────┐
  │    集成测试 (20%)    │
 └─────────────────────┘
┌─────────────────────────┐
│    单元测试 (70%)      │
└─────────────────────────┘
```

#### 1.1.1 单元测试 (70%)

- **目标**: 测试单个组件的功能和逻辑
- **工具**: Vitest + Vue Test Utils
- **覆盖范围**: 组件 Props、Events、Slots、计算属性、方法

#### 1.1.2 集成测试 (20%)

- **目标**: 测试组件间的交互和组合使用
- **工具**: Vitest + Vue Test Utils
- **覆盖范围**: 组件组合、状态管理、路由交互

#### 1.1.3 端到端测试 (10%)

- **目标**: 测试完整的用户场景和跨端兼容性
- **工具**: Playwright
- **覆盖范围**: 用户流程、跨平台兼容性、性能测试

### 1.2 测试分类

#### 1.2.1 功能测试

```typescript
// 组件功能测试示例
describe('KButton 功能测试', () => {
  it('应该正确渲染按钮文本', () => {
    const wrapper = mount(KButton, {
      slots: { default: 'Click Me' }
    });
    expect(wrapper.text()).toBe('Click Me');
  });
  
  it('应该在点击时触发 click 事件', async () => {
    const wrapper = mount(KButton);
    await wrapper.trigger('click');
    expect(wrapper.emitted('click')).toHaveLength(1);
  });
  
  it('应该在禁用状态下不触发点击事件', async () => {
    const wrapper = mount(KButton, {
      props: { disabled: true }
    });
    await wrapper.trigger('click');
    expect(wrapper.emitted('click')).toBeUndefined();
  });
});
```

#### 1.2.2 样式测试

```typescript
// 样式测试示例
describe('KButton 样式测试', () => {
  it('应该应用正确的主题类名', () => {
    const wrapper = mount(KButton, {
      props: { type: 'primary' }
    });
    expect(wrapper.classes()).toContain('k-button--primary');
  });
  
  it('应该在暗黑模式下应用暗黑主题', () => {
    const wrapper = mount(KButton, {
      props: { dark: true }
    });
    expect(wrapper.classes()).toContain('k-button--dark');
  });
});
```

#### 1.2.3 可访问性测试

```typescript
// 可访问性测试示例
describe('KButton 可访问性测试', () => {
  it('应该具有正确的 ARIA 属性', () => {
    const wrapper = mount(KButton, {
      props: { disabled: true }
    });
    expect(wrapper.attributes('aria-disabled')).toBe('true');
  });
  
  it('应该支持键盘导航', async () => {
    const wrapper = mount(KButton);
    await wrapper.trigger('keydown.enter');
    expect(wrapper.emitted('click')).toHaveLength(1);
  });
});
```

#### 1.2.4 跨端兼容性测试

```typescript
// 跨端兼容性测试示例
describe('KButton 跨端兼容性测试', () => {
  it('应该在 H5 端正确渲染', () => {
    // 模拟 H5 环境
    vi.mock('#ifdef H5', () => true);
    const wrapper = mount(KButton);
    expect(wrapper.find('.k-button').exists()).toBe(true);
  });
  
  it('应该在小程序端正确渲染', () => {
    // 模拟小程序环境
    vi.mock('#ifdef MP', () => true);
    const wrapper = mount(KButton);
    expect(wrapper.find('.k-button').exists()).toBe(true);
  });
});
```

---

## 2. 测试工具配置

### 2.1 Vitest 配置

#### 2.1.1 基础配置

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config';
import vue from '@vitejs/plugin-vue';
import { resolve } from 'path';

export default defineConfig({
  plugins: [vue()],
  test: {
    // 测试环境
    environment: 'jsdom',
    
    // 全局设置
    globals: true,
    
    // 覆盖率配置
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'dist/',
        '**/*.d.ts',
        '**/*.config.*',
        '**/coverage/**'
      ],
      thresholds: {
        global: {
          branches: 80,
          functions: 80,
          lines: 80,
          statements: 80
        }
      }
    },
    
    // 设置文件
    setupFiles: ['./tests/setup.ts'],
    
    // 包含的测试文件
    include: [
      'src/**/*.{test,spec}.{js,ts,vue}',
      'tests/**/*.{test,spec}.{js,ts,vue}'
    ],
    
    // 排除的文件
    exclude: [
      'node_modules/',
      'dist/',
      '.idea/',
      '.git/',
      '.cache/'
    ],
    
    // 测试超时
    testTimeout: 10000,
    
    // 钩子超时
    hookTimeout: 10000
  },
  
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src'),
      '~': resolve(__dirname, 'src')
    }
  }
});
```

#### 2.1.2 测试设置文件

```typescript
// tests/setup.ts
import { vi } from 'vitest';
import { config } from '@vue/test-utils';

// 全局组件注册
config.global.components = {
  // 注册全局组件
};

// 全局插件
config.global.plugins = [
  // 注册全局插件
];

// 模拟 uni-app API
global.uni = {
  showToast: vi.fn(),
  showModal: vi.fn(),
  navigateTo: vi.fn(),
  redirectTo: vi.fn(),
  switchTab: vi.fn(),
  navigateBack: vi.fn(),
  request: vi.fn(),
  uploadFile: vi.fn(),
  downloadFile: vi.fn(),
  getStorageSync: vi.fn(),
  setStorageSync: vi.fn(),
  removeStorageSync: vi.fn(),
  clearStorageSync: vi.fn()
};

// 模拟 console 方法（避免测试输出干扰）
if (process.env.NODE_ENV === 'test') {
  global.console = {
    ...console,
    log: vi.fn(),
    warn: vi.fn(),
    error: vi.fn()
  };
}

// 模拟 IntersectionObserver
global.IntersectionObserver = vi.fn(() => ({
  observe: vi.fn(),
  disconnect: vi.fn(),
  unobserve: vi.fn()
}));

// 模拟 ResizeObserver
global.ResizeObserver = vi.fn(() => ({
  observe: vi.fn(),
  disconnect: vi.fn(),
  unobserve: vi.fn()
}));

// 模拟 matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: vi.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(),
    removeListener: vi.fn(),
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn()
  }))
});
```

### 2.2 Vue Test Utils 配置

#### 2.2.1 测试工具函数

```typescript
// tests/utils.ts
import { mount, VueWrapper } from '@vue/test-utils';
import { ComponentPublicInstance } from 'vue';

/**
 * 创建组件包装器的工厂函数
 */
export function createWrapper<T extends ComponentPublicInstance>(
  component: any,
  options: any = {}
): VueWrapper<T> {
  return mount(component, {
    global: {
      stubs: {
        // 存根组件
        'u-icon': true,
        'u-loading': true
      },
      mocks: {
        // 模拟对象
        $t: (key: string) => key
      }
    },
    ...options
  });
}

/**
 * 等待 DOM 更新
 */
export async function nextTick(): Promise<void> {
  await new Promise(resolve => setTimeout(resolve, 0));
}

/**
 * 触发事件并等待更新
 */
export async function triggerEvent(
  wrapper: VueWrapper<any>,
  selector: string,
  event: string,
  payload?: any
): Promise<void> {
  const element = wrapper.find(selector);
  await element.trigger(event, payload);
  await nextTick();
}

/**
 * 模拟用户输入
 */
export async function setInputValue(
  wrapper: VueWrapper<any>,
  selector: string,
  value: string
): Promise<void> {
  const input = wrapper.find(selector);
  await input.setValue(value);
  await nextTick();
}

/**
 * 检查组件是否包含指定类名
 */
export function hasClass(
  wrapper: VueWrapper<any>,
  className: string
): boolean {
  return wrapper.classes().includes(className);
}

/**
 * 检查组件是否包含指定属性
 */
export function hasAttribute(
  wrapper: VueWrapper<any>,
  attribute: string,
  value?: string
): boolean {
  const attrs = wrapper.attributes();
  if (value !== undefined) {
    return attrs[attribute] === value;
  }
  return attribute in attrs;
}

/**
 * 模拟异步操作
 */
export function mockAsync<T>(
  fn: () => Promise<T>,
  delay: number = 100
): Promise<T> {
  return new Promise((resolve, reject) => {
    setTimeout(async () => {
      try {
        const result = await fn();
        resolve(result);
      } catch (error) {
        reject(error);
      }
    }, delay);
  });
}

/**
 * 创建模拟的 uni-app 页面实例
 */
export function createMockPage() {
  return {
    $mp: {
      page: {
        route: 'pages/index/index',
        options: {}
      }
    }
  };
}

/**
 * 模拟网络请求
 */
export function mockRequest(
  response: any,
  delay: number = 100
): Promise<any> {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve({
        data: response,
        statusCode: 200,
        header: {},
        cookies: []
      });
    }, delay);
  });
}
```

### 2.3 Playwright 配置

#### 2.3.1 E2E 测试配置

```typescript
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  // 测试目录
  testDir: './e2e',
  
  // 全局设置
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  
  // 报告配置
  reporter: [
    ['html'],
    ['json', { outputFile: 'test-results/results.json' }],
    ['junit', { outputFile: 'test-results/results.xml' }]
  ],
  
  // 全局配置
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure'
  },
  
  // 项目配置
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] }
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] }
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] }
    },
    {
      name: 'Mobile Chrome',
      use: { ...devices['Pixel 5'] }
    },
    {
      name: 'Mobile Safari',
      use: { ...devices['iPhone 12'] }
    }
  ],
  
  // 本地开发服务器
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI
  }
});
```

#### 2.3.2 E2E 测试工具函数

```typescript
// e2e/utils.ts
import { Page, Locator, expect } from '@playwright/test';

/**
 * E2E 测试工具类
 */
export class E2ETestUtils {
  constructor(private page: Page) {}
  
  /**
   * 等待组件加载完成
   */
  async waitForComponent(selector: string): Promise<Locator> {
    const element = this.page.locator(selector);
    await element.waitFor({ state: 'visible' });
    return element;
  }
  
  /**
   * 点击并等待导航
   */
  async clickAndWaitForNavigation(
    selector: string,
    url?: string
  ): Promise<void> {
    const [response] = await Promise.all([
      this.page.waitForLoadState('networkidle'),
      this.page.click(selector)
    ]);
    
    if (url) {
      await expect(this.page).toHaveURL(url);
    }
  }
  
  /**
   * 填写表单
   */
  async fillForm(fields: Record<string, string>): Promise<void> {
    for (const [selector, value] of Object.entries(fields)) {
      await this.page.fill(selector, value);
    }
  }
  
  /**
   * 检查 Toast 消息
   */
  async expectToast(message: string): Promise<void> {
    const toast = this.page.locator('.u-toast');
    await expect(toast).toBeVisible();
    await expect(toast).toContainText(message);
  }
  
  /**
   * 检查 Modal 对话框
   */
  async expectModal(title?: string): Promise<void> {
    const modal = this.page.locator('.u-modal');
    await expect(modal).toBeVisible();
    
    if (title) {
      const modalTitle = modal.locator('.u-modal__title');
      await expect(modalTitle).toContainText(title);
    }
  }
  
  /**
   * 模拟移动端手势
   */
  async swipe(
    selector: string,
    direction: 'left' | 'right' | 'up' | 'down',
    distance: number = 100
  ): Promise<void> {
    const element = this.page.locator(selector);
    const box = await element.boundingBox();
    
    if (!box) {
      throw new Error(`Element ${selector} not found`);
    }
    
    const startX = box.x + box.width / 2;
    const startY = box.y + box.height / 2;
    
    let endX = startX;
    let endY = startY;
    
    switch (direction) {
      case 'left':
        endX = startX - distance;
        break;
      case 'right':
        endX = startX + distance;
        break;
      case 'up':
        endY = startY - distance;
        break;
      case 'down':
        endY = startY + distance;
        break;
    }
    
    await this.page.mouse.move(startX, startY);
    await this.page.mouse.down();
    await this.page.mouse.move(endX, endY);
    await this.page.mouse.up();
  }
  
  /**
   * 检查组件主题
   */
  async expectTheme(theme: 'light' | 'dark'): Promise<void> {
    const body = this.page.locator('body');
    await expect(body).toHaveClass(new RegExp(`theme-${theme}`));
  }
  
  /**
   * 模拟网络状态
   */
  async setNetworkCondition(
    condition: 'online' | 'offline' | 'slow'
  ): Promise<void> {
    switch (condition) {
      case 'offline':
        await this.page.context().setOffline(true);
        break;
      case 'slow':
        await this.page.route('**/*', route => {
          setTimeout(() => route.continue(), 1000);
        });
        break;
      case 'online':
      default:
        await this.page.context().setOffline(false);
        break;
    }
  }
  
  /**
   * 截图对比
   */
  async expectScreenshot(
    name: string,
    selector?: string
  ): Promise<void> {
    if (selector) {
      const element = this.page.locator(selector);
      await expect(element).toHaveScreenshot(`${name}.png`);
    } else {
      await expect(this.page).toHaveScreenshot(`${name}.png`);
    }
  }
}
```

---

## 3. 组件测试模板

### 3.1 基础组件测试模板

```typescript
// components/button/__tests__/button.test.ts
import { describe, it, expect, vi } from 'vitest';
import { mount } from '@vue/test-utils';
import UButton from '../index.vue';
import { createWrapper, triggerEvent, hasClass } from '../../../tests/utils';

describe('UButton', () => {
  // 基础渲染测试
  describe('渲染测试', () => {
    it('应该正确渲染默认按钮', () => {
      const wrapper = createWrapper(UButton);
      expect(wrapper.find('.u-button').exists()).toBe(true);
      expect(wrapper.classes()).toContain('u-button');
    });
    
    it('应该正确渲染按钮文本', () => {
      const wrapper = createWrapper(UButton, {
        slots: { default: 'Click Me' }
      });
      expect(wrapper.text()).toBe('Click Me');
    });
    
    it('应该正确渲染图标', () => {
      const wrapper = createWrapper(UButton, {
        props: { icon: 'home' }
      });
      expect(wrapper.find('.u-button__icon').exists()).toBe(true);
    });
  });
  
  // Props 测试
  describe('Props 测试', () => {
    it('应该正确应用 type 属性', () => {
      const types = ['primary', 'secondary', 'success', 'warning', 'danger'];
      
      types.forEach(type => {
        const wrapper = createWrapper(UButton, {
          props: { type }
        });
        expect(hasClass(wrapper, `u-button--${type}`)).toBe(true);
      });
    });
    
    it('应该正确应用 size 属性', () => {
      const sizes = ['small', 'medium', 'large'];
      
      sizes.forEach(size => {
        const wrapper = createWrapper(UButton, {
          props: { size }
        });
        expect(hasClass(wrapper, `u-button--${size}`)).toBe(true);
      });
    });
    
    it('应该正确应用 disabled 属性', () => {
      const wrapper = createWrapper(UButton, {
        props: { disabled: true }
      });
      expect(hasClass(wrapper, 'u-button--disabled')).toBe(true);
      expect(wrapper.attributes('disabled')).toBeDefined();
    });
    
    it('应该正确应用 loading 属性', () => {
      const wrapper = createWrapper(UButton, {
        props: { loading: true }
      });
      expect(hasClass(wrapper, 'u-button--loading')).toBe(true);
      expect(wrapper.find('.u-button__loading').exists()).toBe(true);
    });
  });
  
  // 事件测试
  describe('事件测试', () => {
    it('应该在点击时触发 click 事件', async () => {
      const wrapper = createWrapper(UButton);
      await triggerEvent(wrapper, '.u-button', 'click');
      expect(wrapper.emitted('click')).toHaveLength(1);
    });
    
    it('应该在禁用状态下不触发点击事件', async () => {
      const wrapper = createWrapper(UButton, {
        props: { disabled: true }
      });
      await triggerEvent(wrapper, '.u-button', 'click');
      expect(wrapper.emitted('click')).toBeUndefined();
    });
    
    it('应该在加载状态下不触发点击事件', async () => {
      const wrapper = createWrapper(UButton, {
        props: { loading: true }
      });
      await triggerEvent(wrapper, '.u-button', 'click');
      expect(wrapper.emitted('click')).toBeUndefined();
    });
    
    it('应该支持键盘事件', async () => {
      const wrapper = createWrapper(UButton);
      await triggerEvent(wrapper, '.u-button', 'keydown.enter');
      expect(wrapper.emitted('click')).toHaveLength(1);
    });
  });
  
  // 插槽测试
  describe('插槽测试', () => {
    it('应该正确渲染默认插槽', () => {
      const wrapper = createWrapper(UButton, {
        slots: {
          default: '<span>Custom Content</span>'
        }
      });
      expect(wrapper.find('span').text()).toBe('Custom Content');
    });
    
    it('应该正确渲染图标插槽', () => {
      const wrapper = createWrapper(UButton, {
        slots: {
          icon: '<i class="custom-icon"></i>'
        }
      });
      expect(wrapper.find('.custom-icon').exists()).toBe(true);
    });
  });
  
  // 可访问性测试
  describe('可访问性测试', () => {
    it('应该具有正确的 ARIA 属性', () => {
      const wrapper = createWrapper(UButton, {
        props: { disabled: true }
      });
      expect(wrapper.attributes('aria-disabled')).toBe('true');
    });
    
    it('应该具有正确的 role 属性', () => {
      const wrapper = createWrapper(UButton);
      expect(wrapper.attributes('role')).toBe('button');
    });
    
    it('应该支持 aria-label', () => {
      const wrapper = createWrapper(UButton, {
        props: { ariaLabel: 'Submit Form' }
      });
      expect(wrapper.attributes('aria-label')).toBe('Submit Form');
    });
  });
  
  // 主题测试
  describe('主题测试', () => {
    it('应该正确应用暗黑主题', () => {
      const wrapper = createWrapper(UButton, {
        props: { dark: true }
      });
      expect(hasClass(wrapper, 'u-button--dark')).toBe(true);
    });
    
    it('应该正确应用自定义主题', () => {
      const wrapper = createWrapper(UButton, {
        props: { theme: 'custom' }
      });
      expect(hasClass(wrapper, 'u-button--custom')).toBe(true);
    });
  });
});
```

### 3.2 表单组件测试模板

```typescript
// components/input/__tests__/input.test.ts
import { describe, it, expect, vi } from 'vitest';
import { mount } from '@vue/test-utils';
import UInput from '../index.vue';
import { createWrapper, setInputValue, triggerEvent } from '../../../tests/utils';

describe('UInput', () => {
  // 双向绑定测试
  describe('双向绑定测试', () => {
    it('应该正确显示初始值', () => {
      const wrapper = createWrapper(UInput, {
        props: { modelValue: 'initial value' }
      });
      const input = wrapper.find('input');
      expect(input.element.value).toBe('initial value');
    });
    
    it('应该在输入时更新值', async () => {
      const wrapper = createWrapper(UInput);
      await setInputValue(wrapper, 'input', 'new value');
      expect(wrapper.emitted('update:modelValue')).toEqual([['new value']]);
    });
    
    it('应该在值变化时触发 change 事件', async () => {
      const wrapper = createWrapper(UInput);
      await setInputValue(wrapper, 'input', 'changed value');
      await triggerEvent(wrapper, 'input', 'blur');
      expect(wrapper.emitted('change')).toEqual([['changed value']]);
    });
  });
  
  // 验证测试
  describe('验证测试', () => {
    it('应该显示错误状态', () => {
      const wrapper = createWrapper(UInput, {
        props: { error: true, errorMessage: 'This field is required' }
      });
      expect(wrapper.classes()).toContain('u-input--error');
      expect(wrapper.find('.u-input__error').text()).toBe('This field is required');
    });
    
    it('应该执行内置验证规则', async () => {
      const wrapper = createWrapper(UInput, {
        props: {
          rules: [{ required: true, message: 'Required field' }]
        }
      });
      
      // 触发验证
      await triggerEvent(wrapper, 'input', 'blur');
      expect(wrapper.classes()).toContain('u-input--error');
    });
    
    it('应该执行自定义验证规则', async () => {
      const customRule = {
        validator: (value: string) => value.length >= 6,
        message: 'Minimum 6 characters'
      };
      
      const wrapper = createWrapper(UInput, {
        props: { rules: [customRule] }
      });
      
      await setInputValue(wrapper, 'input', '123');
      await triggerEvent(wrapper, 'input', 'blur');
      expect(wrapper.find('.u-input__error').text()).toBe('Minimum 6 characters');
    });
  });
  
  // 格式化测试
  describe('格式化测试', () => {
    it('应该正确格式化手机号', async () => {
      const wrapper = createWrapper(UInput, {
        props: { type: 'phone' }
      });
      
      await setInputValue(wrapper, 'input', '13812345678');
      expect(wrapper.find('input').element.value).toBe('138 1234 5678');
    });
    
    it('应该正确格式化银行卡号', async () => {
      const wrapper = createWrapper(UInput, {
        props: { type: 'bankcard' }
      });
      
      await setInputValue(wrapper, 'input', '1234567890123456');
      expect(wrapper.find('input').element.value).toBe('1234 5678 9012 3456');
    });
  });
});
```

### 3.3 复杂组件测试模板

```typescript
// components/table/__tests__/table.test.ts
import { describe, it, expect, vi } from 'vitest';
import { mount } from '@vue/test-utils';
import UTable from '../index.vue';
import { createWrapper, triggerEvent, mockAsync } from '../../../tests/utils';

describe('UTable', () => {
  const mockData = [
    { id: 1, name: 'John', age: 25, email: 'john@example.com' },
    { id: 2, name: 'Jane', age: 30, email: 'jane@example.com' },
    { id: 3, name: 'Bob', age: 35, email: 'bob@example.com' }
  ];
  
  const mockColumns = [
    { key: 'name', title: 'Name', sortable: true },
    { key: 'age', title: 'Age', sortable: true },
    { key: 'email', title: 'Email' }
  ];
  
  // 数据渲染测试
  describe('数据渲染测试', () => {
    it('应该正确渲染表格数据', () => {
      const wrapper = createWrapper(UTable, {
        props: {
          data: mockData,
          columns: mockColumns
        }
      });
      
      const rows = wrapper.findAll('tbody tr');
      expect(rows).toHaveLength(3);
      expect(rows[0].text()).toContain('John');
      expect(rows[1].text()).toContain('Jane');
    });
    
    it('应该正确渲染表头', () => {
      const wrapper = createWrapper(UTable, {
        props: {
          data: mockData,
          columns: mockColumns
        }
      });
      
      const headers = wrapper.findAll('thead th');
      expect(headers).toHaveLength(3);
      expect(headers[0].text()).toBe('Name');
      expect(headers[1].text()).toBe('Age');
    });
    
    it('应该显示空状态', () => {
      const wrapper = createWrapper(UTable, {
        props: {
          data: [],
          columns: mockColumns
        }
      });
      
      expect(wrapper.find('.u-table__empty').exists()).toBe(true);
    });
  });
  
  // 排序测试
  describe('排序测试', () => {
    it('应该支持列排序', async () => {
      const wrapper = createWrapper(UTable, {
        props: {
          data: mockData,
          columns: mockColumns
        }
      });
      
      // 点击排序
      await triggerEvent(wrapper, 'thead th:first-child', 'click');
      expect(wrapper.emitted('sort')).toBeDefined();
    });
    
    it('应该正确显示排序状态', async () => {
      const wrapper = createWrapper(UTable, {
        props: {
          data: mockData,
          columns: mockColumns,
          sortBy: 'name',
          sortOrder: 'asc'
        }
      });
      
      const sortIcon = wrapper.find('.u-table__sort-icon');
      expect(sortIcon.classes()).toContain('u-table__sort-icon--asc');
    });
  });
  
  // 选择测试
  describe('选择测试', () => {
    it('应该支持行选择', async () => {
      const wrapper = createWrapper(UTable, {
        props: {
          data: mockData,
          columns: mockColumns,
          selectable: true
        }
      });
      
      const checkbox = wrapper.find('tbody tr:first-child input[type="checkbox"]');
      await checkbox.setChecked(true);
      expect(wrapper.emitted('select')).toBeDefined();
    });
    
    it('应该支持全选', async () => {
      const wrapper = createWrapper(UTable, {
        props: {
          data: mockData,
          columns: mockColumns,
          selectable: true
        }
      });
      
      const selectAllCheckbox = wrapper.find('thead input[type="checkbox"]');
      await selectAllCheckbox.setChecked(true);
      expect(wrapper.emitted('select-all')).toBeDefined();
    });
  });
  
  // 分页测试
  describe('分页测试', () => {
    it('应该正确显示分页信息', () => {
      const wrapper = createWrapper(UTable, {
        props: {
          data: mockData,
          columns: mockColumns,
          pagination: {
            current: 1,
            pageSize: 10,
            total: 100
          }
        }
      });
      
      const pagination = wrapper.find('.u-table__pagination');
      expect(pagination.exists()).toBe(true);
    });
    
    it('应该支持分页切换', async () => {
      const wrapper = createWrapper(UTable, {
        props: {
          data: mockData,
          columns: mockColumns,
          pagination: {
            current: 1,
            pageSize: 10,
            total: 100
          }
        }
      });
      
      await triggerEvent(wrapper, '.u-pagination__next', 'click');
      expect(wrapper.emitted('page-change')).toBeDefined();
    });
  });
  
  // 异步加载测试
  describe('异步加载测试', () => {
    it('应该显示加载状态', async () => {
      const wrapper = createWrapper(UTable, {
        props: {
          data: [],
          columns: mockColumns,
          loading: true
        }
      });
      
      expect(wrapper.find('.u-table__loading').exists()).toBe(true);
    });
    
    it('应该处理异步数据加载', async () => {
      const loadData = vi.fn().mockResolvedValue(mockData);
      
      const wrapper = createWrapper(UTable, {
        props: {
          data: [],
          columns: mockColumns,
          loadData
        }
      });
      
      await mockAsync(() => loadData());
      expect(loadData).toHaveBeenCalled();
    });
  });
});
```

---

## 4. E2E 测试示例

### 4.1 用户流程测试

```typescript
// e2e/user-flow.spec.ts
import { test, expect } from '@playwright/test';
import { E2ETestUtils } from './utils';

test.describe('用户完整流程测试', () => {
  let utils: E2ETestUtils;
  
  test.beforeEach(async ({ page }) => {
    utils = new E2ETestUtils(page);
    await page.goto('/');
  });
  
  test('用户注册流程', async ({ page }) => {
    // 导航到注册页面
    await utils.clickAndWaitForNavigation('.nav-register', '/register');
    
    // 填写注册表单
    await utils.fillForm({
      '#username': 'testuser',
      '#email': 'test@example.com',
      '#password': 'password123',
      '#confirmPassword': 'password123'
    });
    
    // 提交表单
    await page.click('.register-form .u-button--primary');
    
    // 验证成功消息
    await utils.expectToast('注册成功');
    
    // 验证跳转到登录页面
    await expect(page).toHaveURL('/login');
  });
  
  test('用户登录流程', async ({ page }) => {
    // 导航到登录页面
    await utils.clickAndWaitForNavigation('.nav-login', '/login');
    
    // 填写登录表单
    await utils.fillForm({
      '#username': 'testuser',
      '#password': 'password123'
    });
    
    // 提交表单
    await page.click('.login-form .u-button--primary');
    
    // 验证登录成功
    await utils.expectToast('登录成功');
    
    // 验证跳转到首页
    await expect(page).toHaveURL('/');
    
    // 验证用户信息显示
    await expect(page.locator('.user-info')).toContainText('testuser');
  });
  
  test('购物车流程', async ({ page }) => {
    // 先登录
    await page.goto('/login');
    await utils.fillForm({
      '#username': 'testuser',
      '#password': 'password123'
    });
    await page.click('.login-form .u-button--primary');
    
    // 浏览商品
    await page.goto('/products');
    
    // 添加商品到购物车
    await page.click('.product-item:first-child .add-to-cart');
    await utils.expectToast('已添加到购物车');
    
    // 查看购物车
    await page.click('.cart-icon');
    await expect(page.locator('.cart-items')).toBeVisible();
    
    // 修改商品数量
    await page.click('.cart-item .quantity-increase');
    await expect(page.locator('.cart-item .quantity')).toContainText('2');
    
    // 结算
    await page.click('.checkout-button');
    await expect(page).toHaveURL('/checkout');
  });
});
```

### 4.2 组件交互测试

```typescript
// e2e/component-interaction.spec.ts
import { test, expect } from '@playwright/test';
import { E2ETestUtils } from './utils';

test.describe('组件交互测试', () => {
  let utils: E2ETestUtils;
  
  test.beforeEach(async ({ page }) => {
    utils = new E2ETestUtils(page);
    await page.goto('/components');
  });
  
  test('Modal 组件交互', async ({ page }) => {
    // 打开 Modal
    await page.click('.open-modal-btn');
    await utils.expectModal('确认操作');
    
    // 测试 Modal 遮罩点击关闭
    await page.click('.u-modal__overlay');
    await expect(page.locator('.u-modal')).not.toBeVisible();
    
    // 重新打开 Modal
    await page.click('.open-modal-btn');
    
    // 测试取消按钮
    await page.click('.u-modal .u-button--secondary');
    await expect(page.locator('.u-modal')).not.toBeVisible();
    
    // 测试确认按钮
    await page.click('.open-modal-btn');
    await page.click('.u-modal .u-button--primary');
    await utils.expectToast('操作成功');
  });
  
  test('Swiper 组件交互', async ({ page }) => {
    const swiper = page.locator('.u-swiper');
    await expect(swiper).toBeVisible();
    
    // 测试手势滑动
    await utils.swipe('.u-swiper', 'left', 200);
    
    // 验证滑动到下一页
    await expect(page.locator('.u-swiper__indicator .active')).toHaveAttribute('data-index', '1');
    
    // 测试指示器点击
    await page.click('.u-swiper__indicator[data-index="2"]');
    await expect(page.locator('.u-swiper__indicator .active')).toHaveAttribute('data-index', '2');
    
    // 测试自动播放
    await page.waitForTimeout(3000);
    await expect(page.locator('.u-swiper__indicator .active')).toHaveAttribute('data-index', '3');
  });
  
  test('Form 组件交互', async ({ page }) => {
    // 填写表单
    await utils.fillForm({
      '#name': 'John Doe',
      '#email': 'invalid-email',
      '#phone': '12345'
    });
    
    // 提交表单触发验证
    await page.click('.form-submit');
    
    // 验证错误消息
    await expect(page.locator('.u-input--error')).toHaveCount(2);
    await expect(page.locator('.u-input__error')).toContainText(['邮箱格式不正确', '手机号格式不正确']);
    
    // 修正错误
    await utils.fillForm({
      '#email': 'john@example.com',
      '#phone': '13812345678'
    });
    
    // 重新提交
    await page.click('.form-submit');
    await utils.expectToast('提交成功');
  });
});
```

### 4.3 跨端兼容性测试

```typescript
// e2e/cross-platform.spec.ts
import { test, expect, devices } from '@playwright/test';

test.describe('跨端兼容性测试', () => {
  test('移动端适配测试', async ({ browser }) => {
    const context = await browser.newContext({
      ...devices['iPhone 12']
    });
    const page = await context.newPage();
    
    await page.goto('/');
    
    // 验证移动端布局
    await expect(page.locator('.mobile-layout')).toBeVisible();
    
    // 测试移动端导航
    await page.click('.mobile-menu-toggle');
    await expect(page.locator('.mobile-menu')).toBeVisible();
    
    // 测试触摸交互
    await page.touchscreen.tap(100, 100);
    
    await context.close();
  });
  
  test('平板端适配测试', async ({ browser }) => {
    const context = await browser.newContext({
      ...devices['iPad Pro']
    });
    const page = await context.newPage();
    
    await page.goto('/');
    
    // 验证平板端布局
    await expect(page.locator('.tablet-layout')).toBeVisible();
    
    await context.close();
  });
  
  test('桌面端适配测试', async ({ page }) => {
    await page.setViewportSize({ width: 1920, height: 1080 });
    await page.goto('/');
    
    // 验证桌面端布局
    await expect(page.locator('.desktop-layout')).toBeVisible();
    
    // 测试鼠标悬停效果
    await page.hover('.hover-effect');
    await expect(page.locator('.hover-effect')).toHaveClass(/hover/);
  });
});
```

---

## 5. 测试最佳实践

### 5.1 测试编写原则

#### 5.1.1 AAA 模式

```typescript
// Arrange（准备）- Act（执行）- Assert（断言）
test('应该在点击时触发事件', async () => {
  // Arrange: 准备测试数据和环境
  const wrapper = createWrapper(UButton);
  const clickHandler = vi.fn();
  wrapper.vm.$emit = clickHandler;
  
  // Act: 执行被测试的操作
  await wrapper.trigger('click');
  
  // Assert: 验证结果
  expect(wrapper.emitted('click')).toHaveLength(1);
});
```

#### 5.1.2 测试隔离

```typescript
// 每个测试都应该是独立的
describe('UCounter', () => {
  let wrapper: VueWrapper<any>;
  
  beforeEach(() => {
    // 每个测试前重新创建组件
    wrapper = createWrapper(UCounter, {
      props: { initialValue: 0 }
    });
  });
  
  afterEach(() => {
    // 清理测试环境
    wrapper.unmount();
  });
  
  test('应该显示初始值', () => {
    expect(wrapper.text()).toContain('0');
  });
  
  test('应该能够增加计数', async () => {
    await wrapper.find('.increment').trigger('click');
    expect(wrapper.text()).toContain('1');
  });
});
```

#### 5.1.3 描述性测试名称

```typescript
// 好的测试名称
test('应该在用户点击提交按钮时验证表单并显示错误消息');
test('应该在网络请求失败时显示重试按钮');
test('应该在暗黑模式下应用正确的主题样式');

// 不好的测试名称
test('测试按钮');
test('验证功能');
test('检查样式');
```

### 5.2 Mock 和 Stub 策略

#### 5.2.1 API Mock

```typescript
// 模拟 HTTP 请求
import { vi } from 'vitest';

// 全局 Mock
vi.mock('@/api/user', () => ({
  getUserInfo: vi.fn().mockResolvedValue({
    id: 1,
    name: 'John Doe',
    email: 'john@example.com'
  }),
  updateUser: vi.fn().mockResolvedValue({ success: true })
}));

// 测试中使用
test('应该加载用户信息', async () => {
  const { getUserInfo } = await import('@/api/user');
  
  const wrapper = createWrapper(UserProfile);
  await wrapper.vm.loadUserInfo();
  
  expect(getUserInfo).toHaveBeenCalled();
  expect(wrapper.text()).toContain('John Doe');
});
```

#### 5.2.2 组件 Stub

```typescript
// 存根复杂的子组件
const wrapper = createWrapper(ParentComponent, {
  global: {
    stubs: {
      'complex-chart': {
        template: '<div class="chart-stub">Chart Placeholder</div>'
      },
      'async-component': true // 简单存根
    }
  }
});
```

#### 5.2.3 时间 Mock

```typescript
// 模拟时间
import { vi } from 'vitest';

test('应该显示正确的时间格式', () => {
  // 固定时间
  const mockDate = new Date('2023-01-01T12:00:00Z');
  vi.setSystemTime(mockDate);
  
  const wrapper = createWrapper(TimeDisplay);
  expect(wrapper.text()).toContain('2023-01-01 12:00:00');
  
  // 恢复真实时间
  vi.useRealTimers();
});
```

### 5.3 测试数据管理

#### 5.3.1 测试数据工厂

```typescript
// tests/factories/user.ts
export const createUser = (overrides: Partial<User> = {}): User => ({
  id: 1,
  name: 'John Doe',
  email: 'john@example.com',
  age: 25,
  role: 'user',
  createdAt: new Date('2023-01-01'),
  ...overrides
});

export const createUsers = (count: number): User[] => {
  return Array.from({ length: count }, (_, index) => 
    createUser({ id: index + 1, name: `User ${index + 1}` })
  );
};

// 使用
test('应该显示用户列表', () => {
  const users = createUsers(5);
  const wrapper = createWrapper(UserList, {
    props: { users }
  });
  
  expect(wrapper.findAll('.user-item')).toHaveLength(5);
});
```

#### 5.3.2 测试夹具

```typescript
// tests/fixtures/api-responses.ts
export const apiResponses = {
  userList: {
    data: [
      { id: 1, name: 'John', email: 'john@example.com' },
      { id: 2, name: 'Jane', email: 'jane@example.com' }
    ],
    total: 2,
    page: 1,
    pageSize: 10
  },
  
  userDetail: {
    id: 1,
    name: 'John Doe',
    email: 'john@example.com',
    profile: {
      avatar: 'https://example.com/avatar.jpg',
      bio: 'Software Developer'
    }
  },
  
  error: {
    code: 400,
    message: 'Bad Request',
    details: 'Invalid parameters'
  }
};
```

### 5.4 性能测试

#### 5.4.1 渲染性能测试

```typescript
// 测试组件渲染性能
test('应该在合理时间内渲染大量数据', async () => {
  const largeDataset = createUsers(1000);
  
  const startTime = performance.now();
  const wrapper = createWrapper(UserTable, {
    props: { users: largeDataset }
  });
  await wrapper.vm.$nextTick();
  const endTime = performance.now();
  
  const renderTime = endTime - startTime;
  expect(renderTime).toBeLessThan(100); // 100ms 内完成渲染
});
```

#### 5.4.2 内存泄漏测试

```typescript
// 测试组件销毁后是否正确清理
test('应该在组件销毁时清理事件监听器', () => {
  const addEventListenerSpy = vi.spyOn(window, 'addEventListener');
  const removeEventListenerSpy = vi.spyOn(window, 'removeEventListener');
  
  const wrapper = createWrapper(WindowEventComponent);
  expect(addEventListenerSpy).toHaveBeenCalled();
  
  wrapper.unmount();
  expect(removeEventListenerSpy).toHaveBeenCalled();
  
  addEventListenerSpy.mockRestore();
  removeEventListenerSpy.mockRestore();
});
```

---

## 6. 持续集成测试

### 6.1 GitHub Actions 配置

```yaml
# .github/workflows/test.yml
name: Test

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        node-version: [16.x, 18.x, 20.x]
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run linting
      run: npm run lint
    
    - name: Run type checking
      run: npm run type-check
    
    - name: Run unit tests
      run: npm run test:unit
    
    - name: Run integration tests
      run: npm run test:integration
    
    - name: Upload coverage reports
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/lcov.info
        flags: unittests
        name: codecov-umbrella
  
  e2e:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Use Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18.x'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Install Playwright
      run: npx playwright install --with-deps
    
    - name: Build application
      run: npm run build
    
    - name: Run E2E tests
      run: npm run test:e2e
    
    - name: Upload E2E test results
      uses: actions/upload-artifact@v3
      if: failure()
      with:
        name: playwright-report
        path: playwright-report/
        retention-days: 30
```

### 6.2 测试报告生成

#### 6.2.1 覆盖率报告

```typescript
// vitest.config.ts 覆盖率配置
export default defineConfig({
  test: {
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html', 'lcov'],
      reportsDirectory: './coverage',
      exclude: [
        'node_modules/',
        'dist/',
        '**/*.d.ts',
        '**/*.config.*',
        '**/coverage/**',
        '**/__tests__/**',
        '**/tests/**'
      ],
      thresholds: {
        global: {
          branches: 80,
          functions: 80,
          lines: 80,
          statements: 80
        },
        // 组件级别的覆盖率要求
        'src/components/**/*.vue': {
          branches: 90,
          functions: 90,
          lines: 90,
          statements: 90
        }
      }
    }
  }
});
```

#### 6.2.2 测试报告生成脚本

```typescript
// scripts/generate-test-report.ts
import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';

interface TestResult {
  name: string;
  status: 'passed' | 'failed' | 'skipped';
  duration: number;
  error?: string;
}

interface TestSuite {
  name: string;
  tests: TestResult[];
  duration: number;
  passed: number;
  failed: number;
  skipped: number;
}

class TestReportGenerator {
  private results: TestSuite[] = [];
  
  async generateReport(): Promise<void> {
    console.log('生成测试报告...');
    
    // 运行单元测试
    await this.runUnitTests();
    
    // 运行集成测试
    await this.runIntegrationTests();
    
    // 运行 E2E 测试
    await this.runE2ETests();
    
    // 生成 HTML 报告
    await this.generateHTMLReport();
    
    // 生成 JSON 报告
    await this.generateJSONReport();
    
    console.log('测试报告生成完成');
  }
  
  private async runUnitTests(): Promise<void> {
    try {
      const output = execSync('npm run test:unit -- --reporter=json', {
        encoding: 'utf8'
      });
      
      const result = JSON.parse(output);
      this.results.push(this.parseTestResult('单元测试', result));
    } catch (error) {
      console.error('单元测试执行失败:', error);
    }
  }
  
  private async runIntegrationTests(): Promise<void> {
    try {
      const output = execSync('npm run test:integration -- --reporter=json', {
        encoding: 'utf8'
      });
      
      const result = JSON.parse(output);
      this.results.push(this.parseTestResult('集成测试', result));
    } catch (error) {
      console.error('集成测试执行失败:', error);
    }
  }
  
  private async runE2ETests(): Promise<void> {
    try {
      const output = execSync('npm run test:e2e -- --reporter=json', {
        encoding: 'utf8'
      });
      
      const result = JSON.parse(output);
      this.results.push(this.parseTestResult('E2E测试', result));
    } catch (error) {
      console.error('E2E测试执行失败:', error);
    }
  }
  
  private parseTestResult(suiteName: string, result: any): TestSuite {
    const tests: TestResult[] = result.tests.map((test: any) => ({
      name: test.title,
      status: test.state,
      duration: test.duration,
      error: test.err?.message
    }));
    
    return {
      name: suiteName,
      tests,
      duration: result.stats.duration,
      passed: result.stats.passes,
      failed: result.stats.failures,
      skipped: result.stats.pending
    };
  }
  
  private async generateHTMLReport(): Promise<void> {
    const template = `
<!DOCTYPE html>
<html>
<head>
  <title>u-kit 测试报告</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .summary { background: #f5f5f5; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
    .suite { margin-bottom: 30px; }
    .suite-title { font-size: 18px; font-weight: bold; margin-bottom: 10px; }
    .test { padding: 8px; margin: 4px 0; border-radius: 4px; }
    .test.passed { background: #d4edda; color: #155724; }
    .test.failed { background: #f8d7da; color: #721c24; }
    .test.skipped { background: #fff3cd; color: #856404; }
    .stats { display: flex; gap: 20px; }
    .stat { text-align: center; }
    .stat-value { font-size: 24px; font-weight: bold; }
    .stat-label { font-size: 12px; color: #666; }
  </style>
</head>
<body>
  <h1>u-kit 组件库测试报告</h1>
  
  <div class="summary">
    <h2>测试概览</h2>
    <div class="stats">
      ${this.generateStatsHTML()}
    </div>
  </div>
  
  ${this.results.map(suite => this.generateSuiteHTML(suite)).join('')}
  
  <footer>
    <p>报告生成时间: ${new Date().toLocaleString()}</p>
  </footer>
</body>
</html>
    `;
    
    fs.writeFileSync('test-reports/index.html', template);
  }
  
  private generateStatsHTML(): string {
    const totalTests = this.results.reduce((sum, suite) => sum + suite.tests.length, 0);
    const totalPassed = this.results.reduce((sum, suite) => sum + suite.passed, 0);
    const totalFailed = this.results.reduce((sum, suite) => sum + suite.failed, 0);
    const totalSkipped = this.results.reduce((sum, suite) => sum + suite.skipped, 0);
    
    return `
      <div class="stat">
        <div class="stat-value">${totalTests}</div>
        <div class="stat-label">总测试数</div>
      </div>
      <div class="stat">
        <div class="stat-value" style="color: #28a745;">${totalPassed}</div>
        <div class="stat-label">通过</div>
      </div>
      <div class="stat">
        <div class="stat-value" style="color: #dc3545;">${totalFailed}</div>
        <div class="stat-label">失败</div>
      </div>
      <div class="stat">
        <div class="stat-value" style="color: #ffc107;">${totalSkipped}</div>
        <div class="stat-label">跳过</div>
      </div>
    `;
  }
  
  private generateSuiteHTML(suite: TestSuite): string {
    return `
      <div class="suite">
        <div class="suite-title">${suite.name}</div>
        <p>执行时间: ${suite.duration}ms | 通过: ${suite.passed} | 失败: ${suite.failed} | 跳过: ${suite.skipped}</p>
        ${suite.tests.map(test => `
          <div class="test ${test.status}">
            <strong>${test.name}</strong> (${test.duration}ms)
            ${test.error ? `<br><small>${test.error}</small>` : ''}
          </div>
        `).join('')}
      </div>
    `;
  }
  
  private async generateJSONReport(): Promise<void> {
    const report = {
      timestamp: new Date().toISOString(),
      summary: {
        totalSuites: this.results.length,
        totalTests: this.results.reduce((sum, suite) => sum + suite.tests.length, 0),
        totalPassed: this.results.reduce((sum, suite) => sum + suite.passed, 0),
        totalFailed: this.results.reduce((sum, suite) => sum + suite.failed, 0),
        totalSkipped: this.results.reduce((sum, suite) => sum + suite.skipped, 0),
        totalDuration: this.results.reduce((sum, suite) => sum + suite.duration, 0)
      },
      suites: this.results
    };
    
    fs.writeFileSync('test-reports/report.json', JSON.stringify(report, null, 2));
  }
}

// 执行报告生成
if (require.main === module) {
  const generator = new TestReportGenerator();
  generator.generateReport().catch(console.error);
}
```

---

## 7. 测试工具链

### 7.1 测试脚本配置

```json
// package.json
{
  "scripts": {
    "test": "vitest",
    "test:unit": "vitest run src/**/*.test.ts",
    "test:integration": "vitest run tests/integration/**/*.test.ts",
    "test:e2e": "playwright test",
    "test:coverage": "vitest run --coverage",
    "test:watch": "vitest watch",
    "test:ui": "vitest --ui",
    "test:report": "ts-node scripts/generate-test-report.ts",
    "test:all": "npm run test:unit && npm run test:integration && npm run test:e2e"
  }
}
```

### 7.2 测试环境配置

#### 7.2.1 开发环境

```typescript
// .env.test
NODE_ENV=test
VITE_API_BASE_URL=http://localhost:3001
VITE_MOCK_API=true
VITE_LOG_LEVEL=error
```

#### 7.2.2 CI 环境

```typescript
// .env.ci
NODE_ENV=test
CI=true
VITE_API_BASE_URL=http://test-api.example.com
VITE_MOCK_API=false
VITE_LOG_LEVEL=silent
```

---

## 8. 测试最佳实践总结

### 8.1 测试策略

1. **测试金字塔**: 70% 单元测试，20% 集成测试，10% E2E 测试
2. **测试驱动开发**: 先写测试，再写实现
3. **行为驱动开发**: 关注用户行为和业务价值
4. **持续测试**: 集成到 CI/CD 流程中

### 8.2 测试质量

1. **覆盖率要求**: 代码覆盖率 ≥ 80%，组件覆盖率 ≥ 90%
2. **测试可读性**: 使用描述性的测试名称和清晰的测试结构
3. **测试维护性**: 避免脆弱的测试，使用页面对象模式
4. **测试性能**: 控制测试执行时间，并行执行测试

### 8.3 测试工具

1. **单元测试**: Vitest + Vue Test Utils
2. **E2E 测试**: Playwright
3. **覆盖率**: V8 Coverage
4. **Mock**: Vitest Mock Functions
5. **CI/CD**: GitHub Actions

### 8.4 测试流程

1. **开发阶段**: 编写单元测试和集成测试
2. **提交阶段**: 运行快速测试套件
3. **合并阶段**: 运行完整测试套件
4. **发布阶段**: 运行回归测试和性能测试

---

## 9. 常见问题与解决方案

### 9.1 测试环境问题

**问题**: 测试环境与生产环境不一致
**解决方案**:

- 使用 Docker 容器化测试环境
- 配置环境变量管理不同环境
- 使用相同的依赖版本

### 9.2 异步测试问题

**问题**: 异步操作测试不稳定
**解决方案**:

```typescript
// 使用 waitFor 等待异步操作完成
import { waitFor } from '@testing-library/vue';

test('异步数据加载', async () => {
  const wrapper = mount(AsyncComponent);
  
  await waitFor(() => {
    expect(wrapper.find('.loading').exists()).toBe(false);
    expect(wrapper.find('.data').exists()).toBe(true);
  });
});
```

### 9.3 跨端测试问题

**问题**: 不同平台行为差异
**解决方案**:

```typescript
// 使用条件测试
test.runIf(process.env.PLATFORM === 'h5')('H5 特定功能', () => {
  // H5 平台特定测试
});

test.runIf(process.env.PLATFORM === 'mp')('小程序特定功能', () => {
  // 小程序平台特定测试
});
```

### 9.4 性能测试问题

**问题**: 测试执行时间过长
**解决方案**:

- 并行执行测试
- 使用测试分片
- 优化测试数据
- 使用快照测试减少断言

---

## 10. 测试文档维护

### 10.1 测试文档更新

1. **组件更新时**: 同步更新相关测试
2. **API 变更时**: 更新接口测试
3. **功能增加时**: 添加新的测试用例
4. **Bug 修复时**: 添加回归测试

### 10.2 测试知识分享

1. **团队培训**: 定期进行测试最佳实践培训
2. **代码审查**: 在代码审查中关注测试质量
3. **文档维护**: 保持测试文档的及时更新
4. **经验总结**: 定期总结测试经验和教训

---

通过遵循本文档的测试策略和最佳实践，u-kit 组件库能够确保高质量的代码交付，提供稳定可靠的组件服务。
